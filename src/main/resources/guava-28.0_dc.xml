<?xml version="1.0" encoding="UTF-8"?>
<pmd-cpd>
   <duplication lines="132" tokens="780">
      <file line="180"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/Striped64.java"/>
      <file line="180"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/Striped64.java"/>
      <codefragment><![CDATA[  final void retryUpdate(long x, int[] hc, boolean wasUncontended) {
    int h;
    if (hc == null) {
      threadHashCode.set(hc = new int[1]); // Initialize randomly
      int r = rng.nextInt(); // Avoid zero to allow xorShift rehash
      h = hc[0] = (r == 0) ? 1 : r;
    } else h = hc[0];
    boolean collide = false; // True if last slot nonempty
    for (; ; ) {
      Cell[] as;
      Cell a;
      int n;
      long v;
      if ((as = cells) != null && (n = as.length) > 0) {
        if ((a = as[(n - 1) & h]) == null) {
          if (busy == 0) { // Try to attach new Cell
            Cell r = new Cell(x); // Optimistically create
            if (busy == 0 && casBusy()) {
              boolean created = false;
              try { // Recheck under lock
                Cell[] rs;
                int m, j;
                if ((rs = cells) != null && (m = rs.length) > 0 && rs[j = (m - 1) & h] == null) {
                  rs[j] = r;
                  created = true;
                }
              } finally {
                busy = 0;
              }
              if (created) break;
              continue; // Slot is now non-empty
            }
          }
          collide = false;
        } else if (!wasUncontended) // CAS already known to fail
        wasUncontended = true; // Continue after rehash
        else if (a.cas(v = a.value, fn(v, x))) break;
        else if (n >= NCPU || cells != as) collide = false; // At max size or stale
        else if (!collide) collide = true;
        else if (busy == 0 && casBusy()) {
          try {
            if (cells == as) { // Expand table unless stale
              Cell[] rs = new Cell[n << 1];
              for (int i = 0; i < n; ++i) rs[i] = as[i];
              cells = rs;
            }
          } finally {
            busy = 0;
          }
          collide = false;
          continue; // Retry with expanded table
        }
        h ^= h << 13; // Rehash
        h ^= h >>> 17;
        h ^= h << 5;
        hc[0] = h; // Record index for next time
      } else if (busy == 0 && cells == as && casBusy()) {
        boolean init = false;
        try { // Initialize table
          if (cells == as) {
            Cell[] rs = new Cell[2];
            rs[h & 1] = new Cell(x);
            cells = rs;
            init = true;
          }
        } finally {
          busy = 0;
        }
        if (init) break;
      } else if (casBase(v = base, fn(v, x))) break; // Fall back on using base
    }
  }

  /** Sets base and all cells to the given value. */
  final void internalReset(long initialValue) {
    Cell[] as = cells;
    base = initialValue;
    if (as != null) {
      int n = as.length;
      for (int i = 0; i < n; ++i) {
        Cell a = as[i];
        if (a != null) a.value = initialValue;
      }
    }
  }

  // Unsafe mechanics
  private static final sun.misc.Unsafe UNSAFE;
  private static final long baseOffset;
  private static final long busyOffset;

  static {
    try {
      UNSAFE = getUnsafe();
      Class<?> sk = Striped64.class;
      baseOffset = UNSAFE.objectFieldOffset(sk.getDeclaredField("base"));
      busyOffset = UNSAFE.objectFieldOffset(sk.getDeclaredField("busy"));
    } catch (Exception e) {
      throw new Error(e);
    }
  }

  /**
   * Returns a sun.misc.Unsafe. Suitable for use in a 3rd party package. Replace with a simple call
   * to Unsafe.getUnsafe when integrating into a jdk.
   *
   * @return a sun.misc.Unsafe
   */
  private static sun.misc.Unsafe getUnsafe() {
    try {
      return sun.misc.Unsafe.getUnsafe();
    } catch (SecurityException tryReflectionInstead) {
    }
    try {
      return java.security.AccessController.doPrivileged(
          new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {
            @Override
            public sun.misc.Unsafe run() throws Exception {
              Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;
              for (java.lang.reflect.Field f : k.getDeclaredFields()) {
                f.setAccessible(true);
                Object x = f.get(null);
                if (k.isInstance(x)) return k.cast(x);
              }
              throw new NoSuchFieldError("the Unsafe");
            }
          });
    } catch (java.security.PrivilegedActionException e) {
      throw new RuntimeException("Could not initialize intrinsics", e.getCause());
    }
  }
}]]></codefragment>
   </duplication>
   <duplication lines="151" tokens="485">
      <file line="43"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LongAdder.java"/>
      <file line="41"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/LongAdder.java"/>
      <codefragment><![CDATA[final class LongAdder extends Striped64 implements Serializable, LongAddable {
  private static final long serialVersionUID = 7249069246863182397L;

  /** Version of plus for use in retryUpdate */
  @Override
  final long fn(long v, long x) {
    return v + x;
  }

  /** Creates a new adder with initial sum of zero. */
  public LongAdder() {}

  /**
   * Adds the given value.
   *
   * @param x the value to add
   */
  @Override
  public void add(long x) {
    Cell[] as;
    long b, v;
    int[] hc;
    Cell a;
    int n;
    if ((as = cells) != null || !casBase(b = base, b + x)) {
      boolean uncontended = true;
      if ((hc = threadHashCode.get()) == null
          || as == null
          || (n = as.length) < 1
          || (a = as[(n - 1) & hc[0]]) == null
          || !(uncontended = a.cas(v = a.value, v + x))) retryUpdate(x, hc, uncontended);
    }
  }

  /** Equivalent to {@code add(1)}. */
  @Override
  public void increment() {
    add(1L);
  }

  /** Equivalent to {@code add(-1)}. */
  public void decrement() {
    add(-1L);
  }

  /**
   * Returns the current sum. The returned value is <em>NOT</em> an atomic snapshot; invocation in
   * the absence of concurrent updates returns an accurate result, but concurrent updates that occur
   * while the sum is being calculated might not be incorporated.
   *
   * @return the sum
   */
  @Override
  public long sum() {
    long sum = base;
    Cell[] as = cells;
    if (as != null) {
      int n = as.length;
      for (int i = 0; i < n; ++i) {
        Cell a = as[i];
        if (a != null) sum += a.value;
      }
    }
    return sum;
  }

  /**
   * Resets variables maintaining the sum to zero. This method may be a useful alternative to
   * creating a new adder, but is only effective if there are no concurrent updates. Because this
   * method is intrinsically racy, it should only be used when it is known that no threads are
   * concurrently updating.
   */
  public void reset() {
    internalReset(0L);
  }

  /**
   * Equivalent in effect to {@link #sum} followed by {@link #reset}. This method may apply for
   * example during quiescent points between multithreaded computations. If there are updates
   * concurrent with this method, the returned value is <em>not</em> guaranteed to be the final
   * value occurring before the reset.
   *
   * @return the sum
   */
  public long sumThenReset() {
    long sum = base;
    Cell[] as = cells;
    base = 0L;
    if (as != null) {
      int n = as.length;
      for (int i = 0; i < n; ++i) {
        Cell a = as[i];
        if (a != null) {
          sum += a.value;
          a.value = 0L;
        }
      }
    }
    return sum;
  }

  /**
   * Returns the String representation of the {@link #sum}.
   *
   * @return the String representation of the {@link #sum}
   */
  @Override
  public String toString() {
    return Long.toString(sum());
  }

  /**
   * Equivalent to {@link #sum}.
   *
   * @return the sum
   */
  @Override
  public long longValue() {
    return sum();
  }

  /** Returns the {@link #sum} as an {@code int} after a narrowing primitive conversion. */
  @Override
  public int intValue() {
    return (int) sum();
  }

  /** Returns the {@link #sum} as a {@code float} after a widening primitive conversion. */
  @Override
  public float floatValue() {
    return (float) sum();
  }

  /** Returns the {@link #sum} as a {@code double} after a widening primitive conversion. */
  @Override
  public double doubleValue() {
    return (double) sum();
  }

  private void writeObject(ObjectOutputStream s) throws IOException {
    s.defaultWriteObject();
    s.writeLong(sum());
  }

  private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
    s.defaultReadObject();
    busy = 0;
    cells = null;
    base = s.readLong();
  }
}]]></codefragment>
   </duplication>
   <duplication lines="85" tokens="407">
      <file line="48"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ForwardingBlockingDeque.java"/>
      <file line="46"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/ForwardingBlockingDeque.java"/>
      <codefragment><![CDATA[@GwtIncompatible
public abstract class ForwardingBlockingDeque<E> extends ForwardingDeque<E>
    implements BlockingDeque<E> {

  /** Constructor for use by subclasses. */
  protected ForwardingBlockingDeque() {}

  @Override
  protected abstract BlockingDeque<E> delegate();

  @Override
  public int remainingCapacity() {
    return delegate().remainingCapacity();
  }

  @Override
  public void putFirst(E e) throws InterruptedException {
    delegate().putFirst(e);
  }

  @Override
  public void putLast(E e) throws InterruptedException {
    delegate().putLast(e);
  }

  @Override
  public boolean offerFirst(E e, long timeout, TimeUnit unit) throws InterruptedException {
    return delegate().offerFirst(e, timeout, unit);
  }

  @Override
  public boolean offerLast(E e, long timeout, TimeUnit unit) throws InterruptedException {
    return delegate().offerLast(e, timeout, unit);
  }

  @Override
  public E takeFirst() throws InterruptedException {
    return delegate().takeFirst();
  }

  @Override
  public E takeLast() throws InterruptedException {
    return delegate().takeLast();
  }

  @Override
  public E pollFirst(long timeout, TimeUnit unit) throws InterruptedException {
    return delegate().pollFirst(timeout, unit);
  }

  @Override
  public E pollLast(long timeout, TimeUnit unit) throws InterruptedException {
    return delegate().pollLast(timeout, unit);
  }

  @Override
  public void put(E e) throws InterruptedException {
    delegate().put(e);
  }

  @Override
  public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException {
    return delegate().offer(e, timeout, unit);
  }

  @Override
  public E take() throws InterruptedException {
    return delegate().take();
  }

  @Override
  public E poll(long timeout, TimeUnit unit) throws InterruptedException {
    return delegate().poll(timeout, unit);
  }

  @Override
  public int drainTo(Collection<? super E> c) {
    return delegate().drainTo(c);
  }

  @Override
  public int drainTo(Collection<? super E> c, int maxElements) {
    return delegate().drainTo(c, maxElements);
  }
}]]></codefragment>
   </duplication>
   <duplication lines="70" tokens="276">
      <file line="29"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/ForwardingGraph.java"/>
      <file line="32"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/ForwardingValueGraph.java"/>
      <codefragment><![CDATA[  protected abstract BaseGraph<N> delegate();

  @Override
  public Set<N> nodes() {
    return delegate().nodes();
  }

  /**
   * Defer to {@link AbstractGraph#edges()} (based on {@link #successors(Object)}) for full edges()
   * implementation.
   */
  @Override
  protected long edgeCount() {
    return delegate().edges().size();
  }

  @Override
  public boolean isDirected() {
    return delegate().isDirected();
  }

  @Override
  public boolean allowsSelfLoops() {
    return delegate().allowsSelfLoops();
  }

  @Override
  public ElementOrder<N> nodeOrder() {
    return delegate().nodeOrder();
  }

  @Override
  public Set<N> adjacentNodes(N node) {
    return delegate().adjacentNodes(node);
  }

  @Override
  public Set<N> predecessors(N node) {
    return delegate().predecessors(node);
  }

  @Override
  public Set<N> successors(N node) {
    return delegate().successors(node);
  }

  @Override
  public int degree(N node) {
    return delegate().degree(node);
  }

  @Override
  public int inDegree(N node) {
    return delegate().inDegree(node);
  }

  @Override
  public int outDegree(N node) {
    return delegate().outDegree(node);
  }

  @Override
  public boolean hasEdgeConnecting(N nodeU, N nodeV) {
    return delegate().hasEdgeConnecting(nodeU, nodeV);
  }

  @Override
  public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {
    return delegate().hasEdgeConnecting(endpoints);
  }]]></codefragment>
   </duplication>
   <duplication lines="86" tokens="270">
      <file line="1075"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="1363"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[      super(key, hash, next);
    }

    // The code below is exactly the same for each access entry type.

    volatile long accessTime = Long.MAX_VALUE;

    @Override
    public long getAccessTime() {
      return accessTime;
    }

    @Override
    public void setAccessTime(long time) {
      this.accessTime = time;
    }

    // Guarded By Segment.this
    ReferenceEntry<K, V> nextAccess = nullEntry();

    @Override
    public ReferenceEntry<K, V> getNextInAccessQueue() {
      return nextAccess;
    }

    @Override
    public void setNextInAccessQueue(ReferenceEntry<K, V> next) {
      this.nextAccess = next;
    }

    // Guarded By Segment.this
    ReferenceEntry<K, V> previousAccess = nullEntry();

    @Override
    public ReferenceEntry<K, V> getPreviousInAccessQueue() {
      return previousAccess;
    }

    @Override
    public void setPreviousInAccessQueue(ReferenceEntry<K, V> previous) {
      this.previousAccess = previous;
    }

    // The code below is exactly the same for each write entry type.

    volatile long writeTime = Long.MAX_VALUE;

    @Override
    public long getWriteTime() {
      return writeTime;
    }

    @Override
    public void setWriteTime(long time) {
      this.writeTime = time;
    }

    // Guarded By Segment.this
    ReferenceEntry<K, V> nextWrite = nullEntry();

    @Override
    public ReferenceEntry<K, V> getNextInWriteQueue() {
      return nextWrite;
    }

    @Override
    public void setNextInWriteQueue(ReferenceEntry<K, V> next) {
      this.nextWrite = next;
    }

    // Guarded By Segment.this
    ReferenceEntry<K, V> previousWrite = nullEntry();

    @Override
    public ReferenceEntry<K, V> getPreviousInWriteQueue() {
      return previousWrite;
    }

    @Override
    public void setPreviousInWriteQueue(ReferenceEntry<K, V> previous) {
      this.previousWrite = previous;
    }
  }

  /** Used for weakly-referenced keys. */
  static class WeakEntry<K, V> extends WeakReference<K> implements ReferenceEntry<K, V> {]]></codefragment>
   </duplication>
   <duplication lines="158" tokens="265">
      <file line="23"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/Striped64.java"/>
      <file line="23"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/Striped64.java"/>
      <codefragment><![CDATA[@GwtIncompatible
abstract class Striped64 extends Number {
  /*
   * This class maintains a lazily-initialized table of atomically
   * updated variables, plus an extra "base" field. The table size
   * is a power of two. Indexing uses masked per-thread hash codes.
   * Nearly all declarations in this class are package-private,
   * accessed directly by subclasses.
   *
   * Table entries are of class Cell; a variant of AtomicLong padded
   * to reduce cache contention on most processors. Padding is
   * overkill for most Atomics because they are usually irregularly
   * scattered in memory and thus don't interfere much with each
   * other. But Atomic objects residing in arrays will tend to be
   * placed adjacent to each other, and so will most often share
   * cache lines (with a huge negative performance impact) without
   * this precaution.
   *
   * In part because Cells are relatively large, we avoid creating
   * them until they are needed.  When there is no contention, all
   * updates are made to the base field.  Upon first contention (a
   * failed CAS on base update), the table is initialized to size 2.
   * The table size is doubled upon further contention until
   * reaching the nearest power of two greater than or equal to the
   * number of CPUS. Table slots remain empty (null) until they are
   * needed.
   *
   * A single spinlock ("busy") is used for initializing and
   * resizing the table, as well as populating slots with new Cells.
   * There is no need for a blocking lock; when the lock is not
   * available, threads try other slots (or the base).  During these
   * retries, there is increased contention and reduced locality,
   * which is still better than alternatives.
   *
   * Per-thread hash codes are initialized to random values.
   * Contention and/or table collisions are indicated by failed
   * CASes when performing an update operation (see method
   * retryUpdate). Upon a collision, if the table size is less than
   * the capacity, it is doubled in size unless some other thread
   * holds the lock. If a hashed slot is empty, and lock is
   * available, a new Cell is created. Otherwise, if the slot
   * exists, a CAS is tried.  Retries proceed by "double hashing",
   * using a secondary hash (Marsaglia XorShift) to try to find a
   * free slot.
   *
   * The table size is capped because, when there are more threads
   * than CPUs, supposing that each thread were bound to a CPU,
   * there would exist a perfect hash function mapping threads to
   * slots that eliminates collisions. When we reach capacity, we
   * search for this mapping by randomly varying the hash codes of
   * colliding threads.  Because search is random, and collisions
   * only become known via CAS failures, convergence can be slow,
   * and because threads are typically not bound to CPUS forever,
   * may not occur at all. However, despite these limitations,
   * observed contention rates are typically low in these cases.
   *
   * It is possible for a Cell to become unused when threads that
   * once hashed to it terminate, as well as in the case where
   * doubling the table causes no thread to hash to it under
   * expanded mask.  We do not try to detect or remove such cells,
   * under the assumption that for long-running instances, observed
   * contention levels will recur, so the cells will eventually be
   * needed again; and for short-lived ones, it does not matter.
   */

  /**
   * Padded variant of AtomicLong supporting only raw accesses plus CAS. The value field is placed
   * between pads, hoping that the JVM doesn't reorder them.
   *
   * <p>JVM intrinsics note: It would be possible to use a release-only form of CAS here, if it were
   * provided.
   */
  static final class Cell {
    volatile long p0, p1, p2, p3, p4, p5, p6;
    volatile long value;
    volatile long q0, q1, q2, q3, q4, q5, q6;

    Cell(long x) {
      value = x;
    }

    final boolean cas(long cmp, long val) {
      return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long valueOffset;

    static {
      try {
        UNSAFE = getUnsafe();
        Class<?> ak = Cell.class;
        valueOffset = UNSAFE.objectFieldOffset(ak.getDeclaredField("value"));
      } catch (Exception e) {
        throw new Error(e);
      }
    }
  }

  /**
   * ThreadLocal holding a single-slot int array holding hash code. Unlike the JDK8 version of this
   * class, we use a suboptimal int[] representation to avoid introducing a new type that can impede
   * class-unloading when ThreadLocals are not removed.
   */
  static final ThreadLocal<int[]> threadHashCode = new ThreadLocal<>();

  /** Generator of new random hash codes */
  static final Random rng = new Random();

  /** Number of CPUS, to place bound on table size */
  static final int NCPU = Runtime.getRuntime().availableProcessors();

  /** Table of cells. When non-null, size is a power of 2. */
  transient volatile Cell @Nullable [] cells;

  /**
   * Base value, used mainly when there is no contention, but also as a fallback during table
   * initialization races. Updated via CAS.
   */
  transient volatile long base;

  /** Spinlock (locked via CAS) used when resizing and/or creating Cells. */
  transient volatile int busy;

  /** Package-private default constructor */
  Striped64() {}

  /** CASes the base field. */
  final boolean casBase(long cmp, long val) {
    return UNSAFE.compareAndSwapLong(this, baseOffset, cmp, val);
  }

  /** CASes the busy field from 0 to 1 to acquire lock. */
  final boolean casBusy() {
    return UNSAFE.compareAndSwapInt(this, busyOffset, 0, 1);
  }

  /**
   * Computes the function of current and new value. Subclasses should open-code this update
   * function for most uses, but the virtualized form is needed within retryUpdate.
   *
   * @param currentValue the current value (of either base or a cell)
   * @param newValue the argument from a user update call
   * @return result of the update function
   */
  abstract long fn(long currentValue, long newValue);

  /**
   * Handles cases of updates involving initialization, resizing, creating new Cells, and/or
   * contention. See above for explanation. This method suffers the usual non-modularity problems of
   * optimistic retry code, relying on rechecked sets of reads.
   *
   * @param x the value
   * @param hc the hash code holder
   * @param wasUncontended false if CAS failed before call
   */
  final void retryUpdate(long x, int[] hc, boolean wasUncontended) {]]></codefragment>
   </duplication>
   <duplication lines="84" tokens="238">
      <file line="160"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/AbstractExecutionThreadService.java"/>
      <file line="114"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/AbstractIdleService.java"/>
      <codefragment><![CDATA[        MoreExecutors.newThread(serviceName(), command).start();
      }
    };
  }

  @Override
  public String toString() {
    return serviceName() + " [" + state() + "]";
  }

  @Override
  public final boolean isRunning() {
    return delegate.isRunning();
  }

  @Override
  public final State state() {
    return delegate.state();
  }

  /** @since 13.0 */
  @Override
  public final void addListener(Listener listener, Executor executor) {
    delegate.addListener(listener, executor);
  }

  /** @since 14.0 */
  @Override
  public final Throwable failureCause() {
    return delegate.failureCause();
  }

  /** @since 15.0 */
  @CanIgnoreReturnValue
  @Override
  public final Service startAsync() {
    delegate.startAsync();
    return this;
  }

  /** @since 15.0 */
  @CanIgnoreReturnValue
  @Override
  public final Service stopAsync() {
    delegate.stopAsync();
    return this;
  }

  /** @since 15.0 */
  @Override
  public final void awaitRunning() {
    delegate.awaitRunning();
  }

  /** @since 15.0 */
  @Override
  public final void awaitRunning(long timeout, TimeUnit unit) throws TimeoutException {
    delegate.awaitRunning(timeout, unit);
  }

  /** @since 15.0 */
  @Override
  public final void awaitTerminated() {
    delegate.awaitTerminated();
  }

  /** @since 15.0 */
  @Override
  public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutException {
    delegate.awaitTerminated(timeout, unit);
  }

  /**
   * Returns the name of this service. {@link AbstractExecutionThreadService} may include the name
   * in debugging output.
   *
   * <p>Subclasses may override this method.
   *
   * @since 14.0 (present in 10.0 as getServiceName)
   */
  protected String serviceName() {
    return getClass().getSimpleName();
  }
}]]></codefragment>
   </duplication>
   <duplication lines="62" tokens="223">
      <file line="828"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="1169"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[      throw new UnsupportedOperationException();
    }

    @Override
    public long getAccessTime() {
      throw new UnsupportedOperationException();
    }

    @Override
    public void setAccessTime(long time) {
      throw new UnsupportedOperationException();
    }

    @Override
    public ReferenceEntry<K, V> getNextInAccessQueue() {
      throw new UnsupportedOperationException();
    }

    @Override
    public void setNextInAccessQueue(ReferenceEntry<K, V> next) {
      throw new UnsupportedOperationException();
    }

    @Override
    public ReferenceEntry<K, V> getPreviousInAccessQueue() {
      throw new UnsupportedOperationException();
    }

    @Override
    public void setPreviousInAccessQueue(ReferenceEntry<K, V> previous) {
      throw new UnsupportedOperationException();
    }

    @Override
    public long getWriteTime() {
      throw new UnsupportedOperationException();
    }

    @Override
    public void setWriteTime(long time) {
      throw new UnsupportedOperationException();
    }

    @Override
    public ReferenceEntry<K, V> getNextInWriteQueue() {
      throw new UnsupportedOperationException();
    }

    @Override
    public void setNextInWriteQueue(ReferenceEntry<K, V> next) {
      throw new UnsupportedOperationException();
    }

    @Override
    public ReferenceEntry<K, V> getPreviousInWriteQueue() {
      throw new UnsupportedOperationException();
    }

    @Override
    public void setPreviousInWriteQueue(ReferenceEntry<K, V> previous) {
      throw new UnsupportedOperationException();
    }]]></codefragment>
   </duplication>
   <duplication lines="36" tokens="218">
      <file line="2914"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2976"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[    boolean replace(K key, int hash, V oldValue, V newValue) {
      lock();
      try {
        long now = map.ticker.read();
        preWriteCleanup(now);

        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
        int index = hash & (table.length() - 1);
        ReferenceEntry<K, V> first = table.get(index);

        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {
            ValueReference<K, V> valueReference = e.getValueReference();
            V entryValue = valueReference.get();
            if (entryValue == null) {
              if (valueReference.isActive()) {
                // If the value disappeared, this entry is partially collected.
                int newCount = this.count - 1;
                ++modCount;
                ReferenceEntry<K, V> newFirst =
                    removeValueFromChain(
                        first,
                        e,
                        entryKey,
                        hash,
                        entryValue,
                        valueReference,
                        RemovalCause.COLLECTED);
                newCount = this.count - 1;
                table.set(index, newFirst);
                this.count = newCount; // write-volatile
              }
              return false;]]></codefragment>
   </duplication>
   <duplication lines="65" tokens="213">
      <file line="4319"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2508"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[    @Nullable ReferenceEntry<K, V> nextEntry;
    @Nullable WriteThroughEntry nextExternal;
    @Nullable WriteThroughEntry lastReturned;

    HashIterator() {
      nextSegmentIndex = segments.length - 1;
      nextTableIndex = -1;
      advance();
    }

    @Override
    public abstract T next();

    final void advance() {
      nextExternal = null;

      if (nextInChain()) {
        return;
      }

      if (nextInTable()) {
        return;
      }

      while (nextSegmentIndex >= 0) {
        currentSegment = segments[nextSegmentIndex--];
        if (currentSegment.count != 0) {
          currentTable = currentSegment.table;
          nextTableIndex = currentTable.length() - 1;
          if (nextInTable()) {
            return;
          }
        }
      }
    }

    /** Finds the next entry in the current chain. Returns true if an entry was found. */
    boolean nextInChain() {
      if (nextEntry != null) {
        for (nextEntry = nextEntry.getNext(); nextEntry != null; nextEntry = nextEntry.getNext()) {
          if (advanceTo(nextEntry)) {
            return true;
          }
        }
      }
      return false;
    }

    /** Finds the next entry in the current table. Returns true if an entry was found. */
    boolean nextInTable() {
      while (nextTableIndex >= 0) {
        if ((nextEntry = currentTable.get(nextTableIndex--)) != null) {
          if (advanceTo(nextEntry) || nextInChain()) {
            return true;
          }
        }
      }
      return false;
    }

    /**
     * Advances to the given entry. Returns true if the entry was valid, false if it should be
     * skipped.
     */
    boolean advanceTo(ReferenceEntry<K, V> entry) {]]></codefragment>
   </duplication>
   <duplication lines="68" tokens="211">
      <file line="163"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/AbstractExecutionThreadService.java"/>
      <file line="117"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/AbstractIdleService.java"/>
      <file line="396"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/AbstractScheduledService.java"/>
      <codefragment><![CDATA[  }

  @Override
  public String toString() {
    return serviceName() + " [" + state() + "]";
  }

  @Override
  public final boolean isRunning() {
    return delegate.isRunning();
  }

  @Override
  public final State state() {
    return delegate.state();
  }

  /** @since 13.0 */
  @Override
  public final void addListener(Listener listener, Executor executor) {
    delegate.addListener(listener, executor);
  }

  /** @since 14.0 */
  @Override
  public final Throwable failureCause() {
    return delegate.failureCause();
  }

  /** @since 15.0 */
  @CanIgnoreReturnValue
  @Override
  public final Service startAsync() {
    delegate.startAsync();
    return this;
  }

  /** @since 15.0 */
  @CanIgnoreReturnValue
  @Override
  public final Service stopAsync() {
    delegate.stopAsync();
    return this;
  }

  /** @since 15.0 */
  @Override
  public final void awaitRunning() {
    delegate.awaitRunning();
  }

  /** @since 15.0 */
  @Override
  public final void awaitRunning(long timeout, TimeUnit unit) throws TimeoutException {
    delegate.awaitRunning(timeout, unit);
  }

  /** @since 15.0 */
  @Override
  public final void awaitTerminated() {
    delegate.awaitTerminated();
  }

  /** @since 15.0 */
  @Override
  public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutException {
    delegate.awaitTerminated(timeout, unit);
  }]]></codefragment>
   </duplication>
   <duplication lines="35" tokens="208">
      <file line="305"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeRangeSet.java"/>
      <file line="707"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeRangeSet.java"/>
      <codefragment><![CDATA[        return ImmutableSortedMap.of();
      }
    }

    @Override
    public NavigableMap<Cut<C>, Range<C>> subMap(
        Cut<C> fromKey, boolean fromInclusive, Cut<C> toKey, boolean toInclusive) {
      return subMap(
          Range.range(
              fromKey, BoundType.forBoolean(fromInclusive),
              toKey, BoundType.forBoolean(toInclusive)));
    }

    @Override
    public NavigableMap<Cut<C>, Range<C>> headMap(Cut<C> toKey, boolean inclusive) {
      return subMap(Range.upTo(toKey, BoundType.forBoolean(inclusive)));
    }

    @Override
    public NavigableMap<Cut<C>, Range<C>> tailMap(Cut<C> fromKey, boolean inclusive) {
      return subMap(Range.downTo(fromKey, BoundType.forBoolean(inclusive)));
    }

    @Override
    public Comparator<? super Cut<C>> comparator() {
      return Ordering.<Cut<C>>natural();
    }

    @Override
    public boolean containsKey(@Nullable Object key) {
      return get(key) != null;
    }

    @Override
    public Range<C> get(@Nullable Object key) {]]></codefragment>
   </duplication>
   <duplication lines="29" tokens="187">
      <file line="305"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeRangeSet.java"/>
      <file line="473"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeRangeSet.java"/>
      <file line="707"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeRangeSet.java"/>
      <codefragment><![CDATA[        return ImmutableSortedMap.of();
      }
    }

    @Override
    public NavigableMap<Cut<C>, Range<C>> subMap(
        Cut<C> fromKey, boolean fromInclusive, Cut<C> toKey, boolean toInclusive) {
      return subMap(
          Range.range(
              fromKey, BoundType.forBoolean(fromInclusive),
              toKey, BoundType.forBoolean(toInclusive)));
    }

    @Override
    public NavigableMap<Cut<C>, Range<C>> headMap(Cut<C> toKey, boolean inclusive) {
      return subMap(Range.upTo(toKey, BoundType.forBoolean(inclusive)));
    }

    @Override
    public NavigableMap<Cut<C>, Range<C>> tailMap(Cut<C> fromKey, boolean inclusive) {
      return subMap(Range.downTo(fromKey, BoundType.forBoolean(inclusive)));
    }

    @Override
    public Comparator<? super Cut<C>> comparator() {
      return Ordering.<Cut<C>>natural();
    }

    @Override]]></codefragment>
   </duplication>
   <duplication lines="28" tokens="171">
      <file line="2770"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3124"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[    V put(K key, int hash, V value, boolean onlyIfAbsent) {
      lock();
      try {
        long now = map.ticker.read();
        preWriteCleanup(now);

        int newCount = this.count + 1;
        if (newCount > this.threshold) { // ensure capacity
          expand();
          newCount = this.count + 1;
        }

        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
        int index = hash & (table.length() - 1);
        ReferenceEntry<K, V> first = table.get(index);

        // Look for an existing entry.
        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {
            // We found an existing entry.

            ValueReference<K, V> valueReference = e.getValueReference();
            V entryValue = valueReference.get();

            if (entryValue == null) {]]></codefragment>
   </duplication>
   <duplication lines="44" tokens="166">
      <file line="227"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableListMultimap.java"/>
      <file line="256"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSetMultimap.java"/>
      <codefragment><![CDATA[    public Builder() {}

    @CanIgnoreReturnValue
    @Override
    public Builder<K, V> put(K key, V value) {
      super.put(key, value);
      return this;
    }

    /**
     * {@inheritDoc}
     *
     * @since 11.0
     */
    @CanIgnoreReturnValue
    @Override
    public Builder<K, V> put(Entry<? extends K, ? extends V> entry) {
      super.put(entry);
      return this;
    }

    /**
     * {@inheritDoc}
     *
     * @since 19.0
     */
    @CanIgnoreReturnValue
    @Beta
    @Override
    public Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries) {
      super.putAll(entries);
      return this;
    }

    @CanIgnoreReturnValue
    @Override
    public Builder<K, V> putAll(K key, Iterable<? extends V> values) {
      super.putAll(key, values);
      return this;
    }

    @CanIgnoreReturnValue
    @Override
    public Builder<K, V> putAll(K key, V... values) {]]></codefragment>
   </duplication>
   <duplication lines="54" tokens="166">
      <file line="856"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/CycleDetectingLockFactory.java"/>
      <file line="915"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/CycleDetectingLockFactory.java"/>
      <codefragment><![CDATA[    CycleDetectingReentrantReadLock(CycleDetectingReentrantReadWriteLock readWriteLock) {
      super(readWriteLock);
      this.readWriteLock = readWriteLock;
    }

    @Override
    public void lock() {
      aboutToAcquire(readWriteLock);
      try {
        super.lock();
      } finally {
        lockStateChanged(readWriteLock);
      }
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {
      aboutToAcquire(readWriteLock);
      try {
        super.lockInterruptibly();
      } finally {
        lockStateChanged(readWriteLock);
      }
    }

    @Override
    public boolean tryLock() {
      aboutToAcquire(readWriteLock);
      try {
        return super.tryLock();
      } finally {
        lockStateChanged(readWriteLock);
      }
    }

    @Override
    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
      aboutToAcquire(readWriteLock);
      try {
        return super.tryLock(timeout, unit);
      } finally {
        lockStateChanged(readWriteLock);
      }
    }

    @Override
    public void unlock() {
      try {
        super.unlock();
      } finally {
        lockStateChanged(readWriteLock);
      }
    }
  }]]></codefragment>
   </duplication>
   <duplication lines="43" tokens="165">
      <file line="1269"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="1361"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[    WeakAccessEntry(ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
      super(queue, key, hash, next);
    }

    // The code below is exactly the same for each access entry type.

    volatile long accessTime = Long.MAX_VALUE;

    @Override
    public long getAccessTime() {
      return accessTime;
    }

    @Override
    public void setAccessTime(long time) {
      this.accessTime = time;
    }

    // Guarded By Segment.this
    ReferenceEntry<K, V> nextAccess = nullEntry();

    @Override
    public ReferenceEntry<K, V> getNextInAccessQueue() {
      return nextAccess;
    }

    @Override
    public void setNextInAccessQueue(ReferenceEntry<K, V> next) {
      this.nextAccess = next;
    }

    // Guarded By Segment.this
    ReferenceEntry<K, V> previousAccess = nullEntry();

    @Override
    public ReferenceEntry<K, V> getPreviousInAccessQueue() {
      return previousAccess;
    }

    @Override
    public void setPreviousInAccessQueue(ReferenceEntry<K, V> previous) {
      this.previousAccess = previous;
    }]]></codefragment>
   </duplication>
   <duplication lines="25" tokens="162">
      <file line="425"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multisets.java"/>
      <file line="559"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multisets.java"/>
      <codefragment><![CDATA[        return Math.max(multiset1.count(element), multiset2.count(element));
      }

      @Override
      Set<E> createElementSet() {
        return Sets.union(multiset1.elementSet(), multiset2.elementSet());
      }

      @Override
      Iterator<E> elementIterator() {
        throw new AssertionError("should never be called");
      }

      @Override
      Iterator<Entry<E>> entryIterator() {
        final Iterator<? extends Entry<? extends E>> iterator1 = multiset1.entrySet().iterator();
        final Iterator<? extends Entry<? extends E>> iterator2 = multiset2.entrySet().iterator();
        // TODO(lowasser): consider making the entries live views
        return new AbstractIterator<Entry<E>>() {
          @Override
          protected Entry<E> computeNext() {
            if (iterator1.hasNext()) {
              Entry<? extends E> entry1 = iterator1.next();
              E element = entry1.getElement();
              int count = Math.max(entry1.getCount(), multiset2.count(element));]]></codefragment>
   </duplication>
   <duplication lines="41" tokens="161">
      <file line="4442"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2630"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[  final class WriteThroughEntry implements Entry<K, V> {
    final K key; // non-null
    V value; // non-null

    WriteThroughEntry(K key, V value) {
      this.key = key;
      this.value = value;
    }

    @Override
    public K getKey() {
      return key;
    }

    @Override
    public V getValue() {
      return value;
    }

    @Override
    public boolean equals(@Nullable Object object) {
      // Cannot use key and value equivalence
      if (object instanceof Entry) {
        Entry<?, ?> that = (Entry<?, ?>) object;
        return key.equals(that.getKey()) && value.equals(that.getValue());
      }
      return false;
    }

    @Override
    public int hashCode() {
      // Cannot use key and value equivalence
      return key.hashCode() ^ value.hashCode();
    }

    @Override
    public V setValue(V newValue) {
      V oldValue = put(key, newValue);
      value = newValue; // only if put succeeds
      return oldValue;
    }]]></codefragment>
   </duplication>
   <duplication lines="27" tokens="161">
      <file line="1598"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1645"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[    boolean replace(K key, int hash, V oldValue, V newValue) {
      lock();
      try {
        preWriteCleanup();

        AtomicReferenceArray<E> table = this.table;
        int index = hash & (table.length() - 1);
        E first = table.get(index);

        for (E e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {
            // If the value disappeared, this entry is partially collected,
            // and we should pretend like it doesn't exist.
            V entryValue = e.getValue();
            if (entryValue == null) {
              if (isCollected(e)) {
                int newCount = this.count - 1;
                ++modCount;
                E newFirst = removeFromChain(first, e);
                newCount = this.count - 1;
                table.set(index, newFirst);
                this.count = newCount; // write-volatile
              }
              return false;]]></codefragment>
   </duplication>
   <duplication lines="26" tokens="158">
      <file line="313"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashMap.java"/>
      <file line="305"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashSet.java"/>
      <codefragment><![CDATA[    this.values = Arrays.copyOf(values, newCapacity);
    long[] entries = this.entries;
    int oldCapacity = entries.length;
    entries = Arrays.copyOf(entries, newCapacity);
    if (newCapacity > oldCapacity) {
      Arrays.fill(entries, oldCapacity, newCapacity, UNSET);
    }
    this.entries = entries;
  }

  private void resizeTable(int newCapacity) { // newCapacity always a power of two
    int[] newTable = newTable(newCapacity);
    long[] entries = this.entries;

    int mask = newTable.length - 1;
    for (int i = 0; i < size; i++) {
      long oldEntry = entries[i];
      int hash = getHash(oldEntry);
      int tableIndex = hash & mask;
      int next = newTable[tableIndex];
      newTable[tableIndex] = i;
      entries[i] = ((long) hash << 32) | (NEXT_MASK & next);
    }

    this.table = newTable;
  }]]></codefragment>
   </duplication>
   <duplication lines="43" tokens="157">
      <file line="982"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="1074"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[    StrongAccessEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {
      super(key, hash, next);
    }

    // The code below is exactly the same for each access entry type.

    volatile long accessTime = Long.MAX_VALUE;

    @Override
    public long getAccessTime() {
      return accessTime;
    }

    @Override
    public void setAccessTime(long time) {
      this.accessTime = time;
    }

    // Guarded By Segment.this
    ReferenceEntry<K, V> nextAccess = nullEntry();

    @Override
    public ReferenceEntry<K, V> getNextInAccessQueue() {
      return nextAccess;
    }

    @Override
    public void setNextInAccessQueue(ReferenceEntry<K, V> next) {
      this.nextAccess = next;
    }

    // Guarded By Segment.this
    ReferenceEntry<K, V> previousAccess = nullEntry();

    @Override
    public ReferenceEntry<K, V> getPreviousInAccessQueue() {
      return previousAccess;
    }

    @Override
    public void setPreviousInAccessQueue(ReferenceEntry<K, V> previous) {
      this.previousAccess = previous;
    }]]></codefragment>
   </duplication>
   <duplication lines="21" tokens="153">
      <file line="3031"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3077"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[    V remove(Object key, int hash) {
      lock();
      try {
        long now = map.ticker.read();
        preWriteCleanup(now);

        int newCount = this.count - 1;
        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
        int index = hash & (table.length() - 1);
        ReferenceEntry<K, V> first = table.get(index);

        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {
            ValueReference<K, V> valueReference = e.getValueReference();
            V entryValue = valueReference.get();

            RemovalCause cause;
            if (entryValue != null) {]]></codefragment>
   </duplication>
   <duplication lines="47" tokens="153">
      <file line="27"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LongAddables.java"/>
      <file line="25"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/LongAddables.java"/>
      <codefragment><![CDATA[final class LongAddables {
  private static final Supplier<LongAddable> SUPPLIER;

  static {
    Supplier<LongAddable> supplier;
    try {
      new LongAdder(); // trigger static initialization of the LongAdder class, which may fail
      supplier =
          new Supplier<LongAddable>() {
            @Override
            public LongAddable get() {
              return new LongAdder();
            }
          };
    } catch (Throwable t) { // we really want to catch *everything*
      supplier =
          new Supplier<LongAddable>() {
            @Override
            public LongAddable get() {
              return new PureJavaLongAddable();
            }
          };
    }
    SUPPLIER = supplier;
  }

  public static LongAddable create() {
    return SUPPLIER.get();
  }

  private static final class PureJavaLongAddable extends AtomicLong implements LongAddable {
    @Override
    public void increment() {
      getAndIncrement();
    }

    @Override
    public void add(long x) {
      getAndAdd(x);
    }

    @Override
    public long sum() {
      return get();
    }
  }
}]]></codefragment>
   </duplication>
   <duplication lines="68" tokens="151">
      <file line="178"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableBiMap.java"/>
      <file line="460"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedMap.java"/>
      <codefragment><![CDATA[      super(size);
    }

    /**
     * Associates {@code key} with {@code value} in the built bimap. Duplicate keys or values are
     * not allowed, and will cause {@link #build} to fail.
     */
    @CanIgnoreReturnValue
    @Override
    public Builder<K, V> put(K key, V value) {
      super.put(key, value);
      return this;
    }

    /**
     * Adds the given {@code entry} to the bimap. Duplicate keys or values are not allowed, and will
     * cause {@link #build} to fail.
     *
     * @since 19.0
     */
    @CanIgnoreReturnValue
    @Override
    public Builder<K, V> put(Entry<? extends K, ? extends V> entry) {
      super.put(entry);
      return this;
    }

    /**
     * Associates all of the given map's keys and values in the built bimap. Duplicate keys or
     * values are not allowed, and will cause {@link #build} to fail.
     *
     * @throws NullPointerException if any key or value in {@code map} is null
     */
    @CanIgnoreReturnValue
    @Override
    public Builder<K, V> putAll(Map<? extends K, ? extends V> map) {
      super.putAll(map);
      return this;
    }

    /**
     * Adds all of the given entries to the built bimap. Duplicate keys or values are not allowed,
     * and will cause {@link #build} to fail.
     *
     * @throws NullPointerException if any key, value, or entry is null
     * @since 19.0
     */
    @CanIgnoreReturnValue
    @Beta
    @Override
    public Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries) {
      super.putAll(entries);
      return this;
    }

    /**
     * Configures this {@code Builder} to order entries by value according to the specified
     * comparator.
     *
     * <p>The sort order is stable, that is, if two entries have values that compare as equivalent,
     * the entry that was inserted first will be first in the built map's iteration order.
     *
     * @throws IllegalStateException if this method was already called
     * @since 19.0
     */
    @CanIgnoreReturnValue
    @Beta
    @Override]]></codefragment>
   </duplication>
   <duplication lines="23" tokens="147">
      <file line="170"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/LittleEndianByteArray.java"/>
      <file line="340"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/UnsignedBytes.java"/>
      <codefragment><![CDATA[      } catch (SecurityException tryReflectionInstead) {
        // We'll try reflection instead.
      }
      try {
        return java.security.AccessController.doPrivileged(
            new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {
              @Override
              public sun.misc.Unsafe run() throws Exception {
                Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;
                for (java.lang.reflect.Field f : k.getDeclaredFields()) {
                  f.setAccessible(true);
                  Object x = f.get(null);
                  if (k.isInstance(x)) {
                    return k.cast(x);
                  }
                }
                throw new NoSuchFieldError("the Unsafe");
              }
            });
      } catch (java.security.PrivilegedActionException e) {
        throw new RuntimeException("Could not initialize intrinsics", e.getCause());
      }
    }]]></codefragment>
   </duplication>
   <duplication lines="32" tokens="145">
      <file line="193"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashMap.java"/>
      <file line="202"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashSet.java"/>
      <codefragment><![CDATA[    this.values = new Object[expectedSize];
  }

  private static int[] newTable(int size) {
    int[] array = new int[size];
    Arrays.fill(array, UNSET);
    return array;
  }

  private static long[] newEntries(int size) {
    long[] array = new long[size];
    Arrays.fill(array, UNSET);
    return array;
  }

  private int hashTableMask() {
    return table.length - 1;
  }

  private static int getHash(long entry) {
    return (int) (entry >>> 32);
  }

  /** Returns the index, or UNSET if the pointer is "null" */
  private static int getNext(long entry) {
    return (int) entry;
  }

  /** Returns a new entry value by changing the "next" index of an existing entry */
  private static long swapNext(long entry, int newNext) {
    return (HASH_MASK & entry) | (NEXT_MASK & newNext);
  }]]></codefragment>
   </duplication>
   <duplication lines="33" tokens="145">
      <file line="263"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Graphs.java"/>
      <file line="308"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Graphs.java"/>
      <codefragment><![CDATA[    protected Graph<N> delegate() {
      return graph;
    }

    @Override
    public Set<N> predecessors(N node) {
      return delegate().successors(node); // transpose
    }

    @Override
    public Set<N> successors(N node) {
      return delegate().predecessors(node); // transpose
    }

    @Override
    public int inDegree(N node) {
      return delegate().outDegree(node); // transpose
    }

    @Override
    public int outDegree(N node) {
      return delegate().inDegree(node); // transpose
    }

    @Override
    public boolean hasEdgeConnecting(N nodeU, N nodeV) {
      return delegate().hasEdgeConnecting(nodeV, nodeU); // transpose
    }

    @Override
    public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {
      return delegate().hasEdgeConnecting(transpose(endpoints));
    }]]></codefragment>
   </duplication>
   <duplication lines="45" tokens="141">
      <file line="983"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="1270"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[      super(key, hash, next);
    }

    // The code below is exactly the same for each access entry type.

    volatile long accessTime = Long.MAX_VALUE;

    @Override
    public long getAccessTime() {
      return accessTime;
    }

    @Override
    public void setAccessTime(long time) {
      this.accessTime = time;
    }

    // Guarded By Segment.this
    ReferenceEntry<K, V> nextAccess = nullEntry();

    @Override
    public ReferenceEntry<K, V> getNextInAccessQueue() {
      return nextAccess;
    }

    @Override
    public void setNextInAccessQueue(ReferenceEntry<K, V> next) {
      this.nextAccess = next;
    }

    // Guarded By Segment.this
    ReferenceEntry<K, V> previousAccess = nullEntry();

    @Override
    public ReferenceEntry<K, V> getPreviousInAccessQueue() {
      return previousAccess;
    }

    @Override
    public void setPreviousInAccessQueue(ReferenceEntry<K, V> previous) {
      this.previousAccess = previous;
    }
  }

  static final class StrongWriteEntry<K, V> extends StrongEntry<K, V> {]]></codefragment>
   </duplication>
   <duplication lines="45" tokens="141">
      <file line="1029"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="1316"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[      super(key, hash, next);
    }

    // The code below is exactly the same for each write entry type.

    volatile long writeTime = Long.MAX_VALUE;

    @Override
    public long getWriteTime() {
      return writeTime;
    }

    @Override
    public void setWriteTime(long time) {
      this.writeTime = time;
    }

    // Guarded By Segment.this
    ReferenceEntry<K, V> nextWrite = nullEntry();

    @Override
    public ReferenceEntry<K, V> getNextInWriteQueue() {
      return nextWrite;
    }

    @Override
    public void setNextInWriteQueue(ReferenceEntry<K, V> next) {
      this.nextWrite = next;
    }

    // Guarded By Segment.this
    ReferenceEntry<K, V> previousWrite = nullEntry();

    @Override
    public ReferenceEntry<K, V> getPreviousInWriteQueue() {
      return previousWrite;
    }

    @Override
    public void setPreviousInWriteQueue(ReferenceEntry<K, V> previous) {
      this.previousWrite = previous;
    }
  }

  static final class StrongAccessWriteEntry<K, V> extends StrongEntry<K, V> {]]></codefragment>
   </duplication>
   <duplication lines="42" tokens="137">
      <file line="983"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="1363"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[      super(key, hash, next);
    }

    // The code below is exactly the same for each access entry type.

    volatile long accessTime = Long.MAX_VALUE;

    @Override
    public long getAccessTime() {
      return accessTime;
    }

    @Override
    public void setAccessTime(long time) {
      this.accessTime = time;
    }

    // Guarded By Segment.this
    ReferenceEntry<K, V> nextAccess = nullEntry();

    @Override
    public ReferenceEntry<K, V> getNextInAccessQueue() {
      return nextAccess;
    }

    @Override
    public void setNextInAccessQueue(ReferenceEntry<K, V> next) {
      this.nextAccess = next;
    }

    // Guarded By Segment.this
    ReferenceEntry<K, V> previousAccess = nullEntry();

    @Override
    public ReferenceEntry<K, V> getPreviousInAccessQueue() {
      return previousAccess;
    }

    @Override
    public void setPreviousInAccessQueue(ReferenceEntry<K, V> previous) {
      this.previousAccess = previous;
    }]]></codefragment>
   </duplication>
   <duplication lines="42" tokens="137">
      <file line="1075"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="1270"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[      super(key, hash, next);
    }

    // The code below is exactly the same for each access entry type.

    volatile long accessTime = Long.MAX_VALUE;

    @Override
    public long getAccessTime() {
      return accessTime;
    }

    @Override
    public void setAccessTime(long time) {
      this.accessTime = time;
    }

    // Guarded By Segment.this
    ReferenceEntry<K, V> nextAccess = nullEntry();

    @Override
    public ReferenceEntry<K, V> getNextInAccessQueue() {
      return nextAccess;
    }

    @Override
    public void setNextInAccessQueue(ReferenceEntry<K, V> next) {
      this.nextAccess = next;
    }

    // Guarded By Segment.this
    ReferenceEntry<K, V> previousAccess = nullEntry();

    @Override
    public ReferenceEntry<K, V> getPreviousInAccessQueue() {
      return previousAccess;
    }

    @Override
    public void setPreviousInAccessQueue(ReferenceEntry<K, V> previous) {
      this.previousAccess = previous;
    }]]></codefragment>
   </duplication>
   <duplication lines="35" tokens="136">
      <file line="86"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/AbstractFuture.java"/>
      <file line="82"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/FluentFuture.java"/>
      <codefragment><![CDATA[  abstract static class TrustedFuture<V> extends AbstractFuture<V> implements Trusted<V> {
    @CanIgnoreReturnValue
    @Override
    public final V get() throws InterruptedException, ExecutionException {
      return super.get();
    }

    @CanIgnoreReturnValue
    @Override
    public final V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException {
      return super.get(timeout, unit);
    }

    @Override
    public final boolean isDone() {
      return super.isDone();
    }

    @Override
    public final boolean isCancelled() {
      return super.isCancelled();
    }

    @Override
    public final void addListener(Runnable listener, Executor executor) {
      super.addListener(listener, executor);
    }

    @CanIgnoreReturnValue
    @Override
    public final boolean cancel(boolean mayInterruptIfRunning) {
      return super.cancel(mayInterruptIfRunning);
    }
  }]]></codefragment>
   </duplication>
   <duplication lines="44" tokens="133">
      <file line="1030"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="1116"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="1317"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="1404"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[    }

    // The code below is exactly the same for each write entry type.

    volatile long writeTime = Long.MAX_VALUE;

    @Override
    public long getWriteTime() {
      return writeTime;
    }

    @Override
    public void setWriteTime(long time) {
      this.writeTime = time;
    }

    // Guarded By Segment.this
    ReferenceEntry<K, V> nextWrite = nullEntry();

    @Override
    public ReferenceEntry<K, V> getNextInWriteQueue() {
      return nextWrite;
    }

    @Override
    public void setNextInWriteQueue(ReferenceEntry<K, V> next) {
      this.nextWrite = next;
    }

    // Guarded By Segment.this
    ReferenceEntry<K, V> previousWrite = nullEntry();

    @Override
    public ReferenceEntry<K, V> getPreviousInWriteQueue() {
      return previousWrite;
    }

    @Override
    public void setPreviousInWriteQueue(ReferenceEntry<K, V> previous) {
      this.previousWrite = previous;
    }
  }

  static final class StrongAccessWriteEntry<K, V> extends StrongEntry<K, V> {]]></codefragment>
   </duplication>
   <duplication lines="31" tokens="133">
      <file line="32"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableBiMapFauxverideShim.java"/>
      <file line="32"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedMapFauxverideShim.java"/>
      <codefragment><![CDATA[abstract class ImmutableBiMapFauxverideShim<K, V> extends ImmutableMap<K, V> {
  /**
   * Not supported. Use {@link ImmutableBiMap#toImmutableBiMap} instead. This method exists only to
   * hide {@link ImmutableMap#toImmutableMap(Function, Function)} from consumers of {@code
   * ImmutableBiMap}.
   *
   * @throws UnsupportedOperationException always
   * @deprecated Use {@link ImmutableBiMap#toImmutableBiMap}.
   */
  @Deprecated
  public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(
      Function<? super T, ? extends K> keyFunction,
      Function<? super T, ? extends V> valueFunction) {
    throw new UnsupportedOperationException();
  }

  /**
   * Not supported. This method does not make sense for {@code BiMap}. This method exists only to
   * hide {@link ImmutableMap#toImmutableMap(Function, Function, BinaryOperator)} from consumers of
   * {@code ImmutableBiMap}.
   *
   * @throws UnsupportedOperationException always
   * @deprecated
   */
  @Deprecated
  public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(
      Function<? super T, ? extends K> keyFunction,
      Function<? super T, ? extends V> valueFunction,
      BinaryOperator<V> mergeFunction) {
    throw new UnsupportedOperationException();
  }]]></codefragment>
   </duplication>
   <duplication lines="15" tokens="131">
      <file line="288"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/Striped64.java"/>
      <file line="167"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/LittleEndianByteArray.java"/>
      <file line="288"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/Striped64.java"/>
      <codefragment><![CDATA[  private static sun.misc.Unsafe getUnsafe() {
    try {
      return sun.misc.Unsafe.getUnsafe();
    } catch (SecurityException tryReflectionInstead) {
    }
    try {
      return java.security.AccessController.doPrivileged(
          new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {
            @Override
            public sun.misc.Unsafe run() throws Exception {
              Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;
              for (java.lang.reflect.Field f : k.getDeclaredFields()) {
                f.setAccessible(true);
                Object x = f.get(null);
                if (k.isInstance(x)) return k.cast(x);]]></codefragment>
   </duplication>
   <duplication lines="16" tokens="127">
      <file line="2782"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2920"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2982"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
        int index = hash & (table.length() - 1);
        ReferenceEntry<K, V> first = table.get(index);

        // Look for an existing entry.
        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {
            // We found an existing entry.

            ValueReference<K, V> valueReference = e.getValueReference();
            V entryValue = valueReference.get();

            if (entryValue == null) {]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="122">
      <file line="2920"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2982"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3136"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
        int index = hash & (table.length() - 1);
        ReferenceEntry<K, V> first = table.get(index);

        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {
            ValueReference<K, V> valueReference = e.getValueReference();
            V entryValue = valueReference.get();
            if (entryValue == null) {]]></codefragment>
   </duplication>
   <duplication lines="14" tokens="120">
      <file line="2782"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2920"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2982"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3038"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3084"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3136"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
        int index = hash & (table.length() - 1);
        ReferenceEntry<K, V> first = table.get(index);

        // Look for an existing entry.
        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {
            // We found an existing entry.

            ValueReference<K, V> valueReference = e.getValueReference();
            V entryValue = valueReference.get();]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="119">
      <file line="3314"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3356"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
        int index = hash & (table.length() - 1);
        ReferenceEntry<K, V> first = table.get(index);

        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {
            ValueReference<K, V> v = e.getValueReference();
            if (v == valueReference) {]]></codefragment>
   </duplication>
   <duplication lines="24" tokens="119">
      <file line="34"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/FilteredEntrySetMultimap.java"/>
      <file line="35"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/FilteredKeySetMultimap.java"/>
      <codefragment><![CDATA[    super(unfiltered, predicate);
  }

  @Override
  public SetMultimap<K, V> unfiltered() {
    return (SetMultimap<K, V>) unfiltered;
  }

  @Override
  public Set<V> get(K key) {
    return (Set<V>) super.get(key);
  }

  @Override
  public Set<V> removeAll(Object key) {
    return (Set<V>) super.removeAll(key);
  }

  @Override
  public Set<V> replaceValues(K key, Iterable<? extends V> values) {
    return (Set<V>) super.replaceValues(key, values);
  }

  @Override]]></codefragment>
   </duplication>
   <duplication lines="18" tokens="119">
      <file line="181"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/PairedStats.java"/>
      <file line="211"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/PairedStatsAccumulator.java"/>
      <codefragment><![CDATA[  public LinearTransformation leastSquaresFit() {
    checkState(count() > 1);
    if (isNaN(sumOfProductsOfDeltas)) {
      return LinearTransformation.forNaN();
    }
    double xSumOfSquaresOfDeltas = xStats.sumOfSquaresOfDeltas();
    if (xSumOfSquaresOfDeltas > 0.0) {
      if (yStats.sumOfSquaresOfDeltas() > 0.0) {
        return LinearTransformation.mapping(xStats.mean(), yStats.mean())
            .withSlope(sumOfProductsOfDeltas / xSumOfSquaresOfDeltas);
      } else {
        return LinearTransformation.horizontal(yStats.mean());
      }
    } else {
      checkState(yStats.sumOfSquaresOfDeltas() > 0.0);
      return LinearTransformation.vertical(xStats.mean());
    }
  }]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="118">
      <file line="1848"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1884"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[        AtomicReferenceArray<E> table = this.table;
        int index = hash & (table.length() - 1);
        E first = table.get(index);

        for (E e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {
            WeakValueReference<K, V, E> v = ((WeakValueEntry<K, V, E>) e).getValueReference();
            if (v == valueReference) {]]></codefragment>
   </duplication>
   <duplication lines="140" tokens="116">
      <file line="114"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Graph.java"/>
      <file line="127"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/ValueGraph.java"/>
      <codefragment><![CDATA[  Set<EndpointPair<N>> edges();

  //
  // Graph properties
  //

  /**
   * Returns true if the edges in this graph are directed. Directed edges connect a {@link
   * EndpointPair#source() source node} to a {@link EndpointPair#target() target node}, while
   * undirected edges connect a pair of nodes to each other.
   */
  @Override
  boolean isDirected();

  /**
   * Returns true if this graph allows self-loops (edges that connect a node to itself). Attempting
   * to add a self-loop to a graph that does not allow them will throw an {@link
   * IllegalArgumentException}.
   */
  @Override
  boolean allowsSelfLoops();

  /** Returns the order of iteration for the elements of {@link #nodes()}. */
  @Override
  ElementOrder<N> nodeOrder();

  //
  // Element-level accessors
  //

  /**
   * Returns the nodes which have an incident edge in common with {@code node} in this graph.
   *
   * <p>This is equal to the union of {@link #predecessors(Object)} and {@link #successors(Object)}.
   *
   * @throws IllegalArgumentException if {@code node} is not an element of this graph
   */
  @Override
  Set<N> adjacentNodes(N node);

  /**
   * Returns all nodes in this graph adjacent to {@code node} which can be reached by traversing
   * {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.
   *
   * <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.
   *
   * @throws IllegalArgumentException if {@code node} is not an element of this graph
   */
  @Override
  Set<N> predecessors(N node);

  /**
   * Returns all nodes in this graph adjacent to {@code node} which can be reached by traversing
   * {@code node}'s outgoing edges in the direction (if any) of the edge.
   *
   * <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.
   *
   * <p>This is <i>not</i> the same as "all nodes reachable from {@code node} by following outgoing
   * edges". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)}.
   *
   * @throws IllegalArgumentException if {@code node} is not an element of this graph
   */
  @Override
  Set<N> successors(N node);

  /**
   * Returns the edges in this graph whose endpoints include {@code node}.
   *
   * <p>This is equal to the union of incoming and outgoing edges.
   *
   * @throws IllegalArgumentException if {@code node} is not an element of this graph
   * @since 24.0
   */
  @Override
  Set<EndpointPair<N>> incidentEdges(N node);

  /**
   * Returns the count of {@code node}'s incident edges, counting self-loops twice (equivalently,
   * the number of times an edge touches {@code node}).
   *
   * <p>For directed graphs, this is equal to {@code inDegree(node) + outDegree(node)}.
   *
   * <p>For undirected graphs, this is equal to {@code incidentEdges(node).size()} + (number of
   * self-loops incident to {@code node}).
   *
   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.
   *
   * @throws IllegalArgumentException if {@code node} is not an element of this graph
   */
  @Override
  int degree(N node);

  /**
   * Returns the count of {@code node}'s incoming edges (equal to {@code predecessors(node).size()})
   * in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.
   *
   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.
   *
   * @throws IllegalArgumentException if {@code node} is not an element of this graph
   */
  @Override
  int inDegree(N node);

  /**
   * Returns the count of {@code node}'s outgoing edges (equal to {@code successors(node).size()})
   * in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.
   *
   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.
   *
   * @throws IllegalArgumentException if {@code node} is not an element of this graph
   */
  @Override
  int outDegree(N node);

  /**
   * Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is
   * equivalent to {@code nodes().contains(nodeU) && successors(nodeU).contains(nodeV)}.
   *
   * <p>In an undirected graph, this is equal to {@code hasEdgeConnecting(nodeV, nodeU)}.
   *
   * @since 23.0
   */
  @Override
  boolean hasEdgeConnecting(N nodeU, N nodeV);

  /**
   * Returns true if there is an edge that directly connects {@code endpoints} (in the order, if
   * any, specified by {@code endpoints}). This is equivalent to {@code
   * edges().contains(endpoints)}.
   *
   * <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the
   * endpoints are unordered and the graph is directed; it simply returns {@code false}. This is for
   * consistency with the behavior of {@link Collection#contains(Object)} (which does not generally
   * throw if the object cannot be present in the collection), and the desire to have this method's
   * behavior be compatible with {@code edges().contains(endpoints)}.
   *
   * @since 27.1
   */
  @Override
  boolean hasEdgeConnecting(EndpointPair<N> endpoints);]]></codefragment>
   </duplication>
   <duplication lines="16" tokens="115">
      <file line="3278"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3389"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        int newCount = count - 1;
        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
        int index = hash & (table.length() - 1);
        ReferenceEntry<K, V> first = table.get(index);

        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {
          if (e == entry) {
            ++modCount;
            ReferenceEntry<K, V> newFirst =
                removeValueFromChain(
                    first,
                    e,
                    e.getKey(),
                    hash,
                    e.getValueReference().get(),
                    e.getValueReference(),]]></codefragment>
   </duplication>
   <duplication lines="23" tokens="114">
      <file line="344"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSet.java"/>
      <file line="27"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/IndexedImmutableSet.java"/>
      <codefragment><![CDATA[  abstract static class Indexed<E> extends ImmutableSet<E> {
    abstract E get(int index);

    @Override
    public UnmodifiableIterator<E> iterator() {
      return asList().iterator();
    }

    @Override
    public Spliterator<E> spliterator() {
      return CollectSpliterators.indexed(size(), SPLITERATOR_CHARACTERISTICS, this::get);
    }

    @Override
    public void forEach(Consumer<? super E> consumer) {
      checkNotNull(consumer);
      int n = size();
      for (int i = 0; i < n; i++) {
        consumer.accept(get(i));
      }
    }

    @Override]]></codefragment>
   </duplication>
   <duplication lines="22" tokens="114">
      <file line="509"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableDoubleArray.java"/>
      <file line="504"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableIntArray.java"/>
      <file line="506"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableLongArray.java"/>
      <codefragment><![CDATA[    public Spliterator<Double> spliterator() {
      return parent.spliterator();
    }

    @Override
    public boolean equals(@Nullable Object object) {
      if (object instanceof AsList) {
        AsList that = (AsList) object;
        return this.parent.equals(that.parent);
      }
      // We could delegate to super now but it would still box too much
      if (!(object instanceof List)) {
        return false;
      }
      List<?> that = (List<?>) object;
      if (this.size() != that.size()) {
        return false;
      }
      int i = parent.start;
      // Since `that` is very likely RandomAccess we could avoid allocating this iterator...
      for (Object element : that) {
        if (!(element instanceof Double) || !areEqual(parent.array[i++], (Double) element)) {]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="113">
      <file line="3037"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3083"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3313"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        int newCount = this.count - 1;
        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
        int index = hash & (table.length() - 1);
        ReferenceEntry<K, V> first = table.get(index);

        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {
            ValueReference<K, V> valueReference = e.getValueReference();]]></codefragment>
   </duplication>
   <duplication lines="15" tokens="112">
      <file line="2195"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2379"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[      lock();
      try {
        // re-read ticker once inside the lock
        long now = map.ticker.read();
        preWriteCleanup(now);

        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
        int index = hash & (table.length() - 1);
        ReferenceEntry<K, V> first = table.get(index);

        for (e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {]]></codefragment>
   </duplication>
   <duplication lines="16" tokens="110">
      <file line="1687"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1727"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[    V remove(Object key, int hash) {
      lock();
      try {
        preWriteCleanup();

        int newCount = this.count - 1;
        AtomicReferenceArray<E> table = this.table;
        int index = hash & (table.length() - 1);
        E first = table.get(index);

        for (E e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {
            V entryValue = e.getValue();]]></codefragment>
   </duplication>
   <duplication lines="32" tokens="109">
      <file line="297"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableDoubleArray.java"/>
      <file line="294"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableIntArray.java"/>
      <file line="296"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableLongArray.java"/>
      <codefragment><![CDATA[        double[] newArray = new double[expandedCapacity(array.length, newCount)];
        System.arraycopy(array, 0, newArray, 0, count);
        this.array = newArray;
      }
    }

    // Unfortunately this is pasted from ImmutableCollection.Builder.
    private static int expandedCapacity(int oldCapacity, int minCapacity) {
      if (minCapacity < 0) {
        throw new AssertionError("cannot store more than MAX_VALUE elements");
      }
      // careful of overflow!
      int newCapacity = oldCapacity + (oldCapacity >> 1) + 1;
      if (newCapacity < minCapacity) {
        newCapacity = Integer.highestOneBit(minCapacity - 1) << 1;
      }
      if (newCapacity < 0) {
        newCapacity = Integer.MAX_VALUE; // guaranteed to be >= newCapacity
      }
      return newCapacity;
    }

    /**
     * Returns a new immutable array. The builder can continue to be used after this call, to append
     * more values and build again.
     *
     * <p><b>Performance note:</b> the returned array is backed by the same array as the builder, so
     * no data is copied as part of this step, but this may occupy more memory than strictly
     * necessary. To copy the data to a right-sized backing array, use {@code .build().trimmed()}.
     */
    @CheckReturnValue
    public ImmutableDoubleArray build() {]]></codefragment>
   </duplication>
   <duplication lines="18" tokens="108">
      <file line="230"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/DenseImmutableTable.java"/>
      <file line="86"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/SparseImmutableTable.java"/>
      <codefragment><![CDATA[  }

  @Override
  public ImmutableMap<C, Map<R, V>> columnMap() {
    // Casts without copying.
    ImmutableMap<C, ImmutableMap<R, V>> columnMap = this.columnMap;
    return ImmutableMap.<C, Map<R, V>>copyOf(columnMap);
  }

  @Override
  public ImmutableMap<R, Map<C, V>> rowMap() {
    // Casts without copying.
    ImmutableMap<R, ImmutableMap<C, V>> rowMap = this.rowMap;
    return ImmutableMap.<R, Map<C, V>>copyOf(rowMap);
  }

  @Override
  public V get(@Nullable Object rowKey, @Nullable Object columnKey) {]]></codefragment>
   </duplication>
   <duplication lines="21" tokens="107">
      <file line="3906"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2303"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[    Segment<K, V>[] segments = this.segments;
    for (int i = 0; i < segments.length; ++i) {
      if (segments[i].count != 0) {
        return false;
      }
      sum += segments[i].modCount;
    }

    if (sum != 0L) { // recheck unless no modifications
      for (int i = 0; i < segments.length; ++i) {
        if (segments[i].count != 0) {
          return false;
        }
        sum -= segments[i].modCount;
      }
      if (sum != 0L) {
        return false;
      }
    }
    return true;
  }]]></codefragment>
   </duplication>
   <duplication lines="15" tokens="106">
      <file line="175"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/LittleEndianByteArray.java"/>
      <file line="345"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/UnsignedBytes.java"/>
      <file line="1188"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/AbstractFuture.java"/>
      <codefragment><![CDATA[            new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {
              @Override
              public sun.misc.Unsafe run() throws Exception {
                Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;
                for (java.lang.reflect.Field f : k.getDeclaredFields()) {
                  f.setAccessible(true);
                  Object x = f.get(null);
                  if (k.isInstance(x)) {
                    return k.cast(x);
                  }
                }
                throw new NoSuchFieldError("the Unsafe");
              }
            });
      } catch (java.security.PrivilegedActionException e) {]]></codefragment>
   </duplication>
   <duplication lines="13" tokens="105">
      <file line="2782"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2920"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2982"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3038"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3084"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3136"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3314"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3356"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
        int index = hash & (table.length() - 1);
        ReferenceEntry<K, V> first = table.get(index);

        // Look for an existing entry.
        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {
            // We found an existing entry.

            ValueReference<K, V> valueReference = e.getValueReference();]]></codefragment>
   </duplication>
   <duplication lines="23" tokens="105">
      <file line="338"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Traverser.java"/>
      <file line="504"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Traverser.java"/>
      <codefragment><![CDATA[        checkThatNodeIsInGraph(startNode);
      }
      return new Iterable<N>() {
        @Override
        public Iterator<N> iterator() {
          return new BreadthFirstIterator(startNodes);
        }
      };
    }

    @Override
    public Iterable<N> depthFirstPreOrder(final N startNode) {
      checkNotNull(startNode);
      return depthFirstPreOrder(ImmutableSet.of(startNode));
    }

    @Override
    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {
      checkNotNull(startNodes);
      if (Iterables.isEmpty(startNodes)) {
        return ImmutableSet.of();
      }
      for (N startNode : startNodes) {]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="103">
      <file line="291"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/Striped64.java"/>
      <file line="291"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/Striped64.java"/>
      <file line="340"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/UnsignedBytes.java"/>
      <codefragment><![CDATA[    } catch (SecurityException tryReflectionInstead) {
    }
    try {
      return java.security.AccessController.doPrivileged(
          new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {
            @Override
            public sun.misc.Unsafe run() throws Exception {
              Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;
              for (java.lang.reflect.Field f : k.getDeclaredFields()) {
                f.setAccessible(true);
                Object x = f.get(null);
                if (k.isInstance(x)) return k.cast(x);]]></codefragment>
   </duplication>
   <duplication lines="56" tokens="103">
      <file line="240"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableCollection.java"/>
      <file line="622"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Sets.java"/>
      <codefragment><![CDATA[  @CanIgnoreReturnValue
  @Deprecated
  @Override
  public final boolean add(E e) {
    throw new UnsupportedOperationException();
  }

  /**
   * Guaranteed to throw an exception and leave the collection unmodified.
   *
   * @throws UnsupportedOperationException always
   * @deprecated Unsupported operation.
   */
  @CanIgnoreReturnValue
  @Deprecated
  @Override
  public final boolean remove(Object object) {
    throw new UnsupportedOperationException();
  }

  /**
   * Guaranteed to throw an exception and leave the collection unmodified.
   *
   * @throws UnsupportedOperationException always
   * @deprecated Unsupported operation.
   */
  @CanIgnoreReturnValue
  @Deprecated
  @Override
  public final boolean addAll(Collection<? extends E> newElements) {
    throw new UnsupportedOperationException();
  }

  /**
   * Guaranteed to throw an exception and leave the collection unmodified.
   *
   * @throws UnsupportedOperationException always
   * @deprecated Unsupported operation.
   */
  @CanIgnoreReturnValue
  @Deprecated
  @Override
  public final boolean removeAll(Collection<?> oldElements) {
    throw new UnsupportedOperationException();
  }

  /**
   * Guaranteed to throw an exception and leave the collection unmodified.
   *
   * @throws UnsupportedOperationException always
   * @deprecated Unsupported operation.
   */
  @CanIgnoreReturnValue
  @Deprecated
  @Override
  public final boolean removeIf(Predicate<? super E> filter) {]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="102">
      <file line="2095"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2201"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
        int index = hash & (table.length() - 1);
        ReferenceEntry<K, V> first = table.get(index);

        for (e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {
            valueReference = e.getValueReference();
            if (valueReference.isLoading()) {]]></codefragment>
   </duplication>
   <duplication lines="20" tokens="102">
      <file line="466"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Booleans.java"/>
      <file line="327"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Bytes.java"/>
      <file line="598"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Chars.java"/>
      <file line="608"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Doubles.java"/>
      <file line="594"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Floats.java"/>
      <file line="652"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Ints.java"/>
      <file line="749"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Longs.java"/>
      <file line="645"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Shorts.java"/>
      <codefragment><![CDATA[        BooleanArrayAsList that = (BooleanArrayAsList) object;
        int size = size();
        if (that.size() != size) {
          return false;
        }
        for (int i = 0; i < size; i++) {
          if (array[start + i] != that.array[that.start + i]) {
            return false;
          }
        }
        return true;
      }
      return super.equals(object);
    }

    @Override
    public int hashCode() {
      int result = 1;
      for (int i = start; i < end; i++) {
        result = 31 * result + Booleans.hashCode(array[i]);]]></codefragment>
   </duplication>
   <duplication lines="44" tokens="101">
      <file line="184"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableListMultimap.java"/>
      <file line="209"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSetMultimap.java"/>
      <codefragment><![CDATA[    ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();
    builder.put(k1, v1);
    builder.put(k2, v2);
    builder.put(k3, v3);
    builder.put(k4, v4);
    builder.put(k5, v5);
    return builder.build();
  }

  // looking for of() with > 5 entries? Use the builder instead.

  /**
   * Returns a new builder. The generated builder is equivalent to the builder created by the {@link
   * Builder} constructor.
   */
  public static <K, V> Builder<K, V> builder() {
    return new Builder<>();
  }

  /**
   * A builder for creating immutable {@code ListMultimap} instances, especially {@code public
   * static final} multimaps ("constant multimaps"). Example:
   *
   * <pre>{@code
   * static final Multimap<String, Integer> STRING_TO_INTEGER_MULTIMAP =
   *     new ImmutableListMultimap.Builder<String, Integer>()
   *         .put("one", 1)
   *         .putAll("several", 1, 2, 3)
   *         .putAll("many", 1, 2, 3, 4, 5)
   *         .build();
   * }</pre>
   *
   * <p>Builder instances can be reused; it is safe to call {@link #build} multiple times to build
   * multiple multimaps in series. Each multimap contains the key-value mappings in the previously
   * created multimaps.
   *
   * @since 2.0
   */
  public static final class Builder<K, V> extends ImmutableMultimap.Builder<K, V> {
    /**
     * Creates a new builder. The returned builder is equivalent to the builder generated by {@link
     * ImmutableListMultimap#builder}.
     */
    public Builder() {}]]></codefragment>
   </duplication>
   <duplication lines="22" tokens="100">
      <file line="1451"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="1495"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[    WeakValueReference(ReferenceQueue<V> queue, V referent, ReferenceEntry<K, V> entry) {
      super(referent, queue);
      this.entry = entry;
    }

    @Override
    public int getWeight() {
      return 1;
    }

    @Override
    public ReferenceEntry<K, V> getEntry() {
      return entry;
    }

    @Override
    public void notifyNewValue(V newValue) {}

    @Override
    public ValueReference<K, V> copyFor(
        ReferenceQueue<V> queue, V value, ReferenceEntry<K, V> entry) {
      return new WeakValueReference<>(queue, value, entry);]]></codefragment>
   </duplication>
   <duplication lines="26" tokens="100">
      <file line="425"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashMap.java"/>
      <file line="395"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashSet.java"/>
      <codefragment><![CDATA[      values[srcIndex] = null;

      // move the last entry to the removed spot, just like we moved the element
      long lastEntry = entries[srcIndex];
      entries[dstIndex] = lastEntry;
      entries[srcIndex] = UNSET;

      // also need to update whoever's "next" pointer was pointing to the last entry place
      // reusing "tableIndex" and "next"; these variables were no longer needed
      int tableIndex = getHash(lastEntry) & hashTableMask();
      int lastNext = table[tableIndex];
      if (lastNext == srcIndex) {
        // we need to update the root pointer
        table[tableIndex] = dstIndex;
      } else {
        // we need to update a pointer in an entry
        int previous;
        long entry;
        do {
          previous = lastNext;
          lastNext = getNext(entry = entries[lastNext]);
        } while (lastNext != srcIndex);
        // here, entries[previous] points to the old entry location; update it
        entries[previous] = swapNext(entry, dstIndex);
      }
    } else {]]></codefragment>
   </duplication>
   <duplication lines="37" tokens="100">
      <file line="279"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableListMultimap.java"/>
      <file line="311"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSetMultimap.java"/>
      <codefragment><![CDATA[      return this;
    }

    @CanIgnoreReturnValue
    @Override
    Builder<K, V> combine(ImmutableMultimap.Builder<K, V> other) {
      super.combine(other);
      return this;
    }

    /**
     * {@inheritDoc}
     *
     * @since 8.0
     */
    @CanIgnoreReturnValue
    @Override
    public Builder<K, V> orderKeysBy(Comparator<? super K> keyComparator) {
      super.orderKeysBy(keyComparator);
      return this;
    }

    /**
     * {@inheritDoc}
     *
     * @since 8.0
     */
    @CanIgnoreReturnValue
    @Override
    public Builder<K, V> orderValuesBy(Comparator<? super V> valueComparator) {
      super.orderValuesBy(valueComparator);
      return this;
    }

    /** Returns a newly-created immutable list multimap. */
    @Override
    public ImmutableListMultimap<K, V> build() {]]></codefragment>
   </duplication>
   <duplication lines="31" tokens="100">
      <file line="584"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableDoubleArray.java"/>
      <file line="574"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableIntArray.java"/>
      <file line="576"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableLongArray.java"/>
      <codefragment><![CDATA[      hash += Doubles.hashCode(array[i]);
    }
    return hash;
  }

  /**
   * Returns a string representation of this array in the same form as {@link
   * Arrays#toString(double[])}, for example {@code "[1, 2, 3]"}.
   */
  @Override
  public String toString() {
    if (isEmpty()) {
      return "[]";
    }
    StringBuilder builder = new StringBuilder(length() * 5); // rough estimate is fine
    builder.append('[').append(array[start]);

    for (int i = start + 1; i < end; i++) {
      builder.append(", ").append(array[i]);
    }
    builder.append(']');
    return builder.toString();
  }

  /**
   * Returns an immutable array containing the same values as {@code this} array. This is logically
   * a no-op, and in some circumstances {@code this} itself is returned. However, if this instance
   * is a {@link #subArray} view of a larger array, this method will copy only the appropriate range
   * of values, resulting in an equivalent array with a smaller memory footprint.
   */
  public ImmutableDoubleArray trimmed() {]]></codefragment>
   </duplication>
   <duplication lines="15" tokens="99">
      <file line="1483"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1603"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1650"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[        AtomicReferenceArray<E> table = this.table;
        int index = hash & (table.length() - 1);
        E first = table.get(index);

        // Look for an existing entry.
        for (E e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {
            // We found an existing entry.

            V entryValue = e.getValue();

            if (entryValue == null) {]]></codefragment>
   </duplication>
   <duplication lines="18" tokens="98">
      <file line="1820"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1912"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[        int newCount = count - 1;
        AtomicReferenceArray<E> table = this.table;
        int index = hash & (table.length() - 1);
        E first = table.get(index);

        for (E e = first; e != null; e = e.getNext()) {
          if (e == entry) {
            ++modCount;
            E newFirst = removeFromChain(first, e);
            newCount = this.count - 1;
            table.set(index, newFirst);
            this.count = newCount; // write-volatile
            return true;
          }
        }

        return false;
      } finally {]]></codefragment>
   </duplication>
   <duplication lines="28" tokens="98">
      <file line="185"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Booleans.java"/>
      <file line="111"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Bytes.java"/>
      <file line="168"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Chars.java"/>
      <file line="161"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Doubles.java"/>
      <file line="156"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Floats.java"/>
      <file line="174"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Ints.java"/>
      <file line="146"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Longs.java"/>
      <file line="172"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Shorts.java"/>
      <codefragment><![CDATA[  public static int indexOf(boolean[] array, boolean[] target) {
    checkNotNull(array, "array");
    checkNotNull(target, "target");
    if (target.length == 0) {
      return 0;
    }

    outer:
    for (int i = 0; i < array.length - target.length + 1; i++) {
      for (int j = 0; j < target.length; j++) {
        if (array[i + j] != target[j]) {
          continue outer;
        }
      }
      return i;
    }
    return -1;
  }

  /**
   * Returns the index of the last appearance of the value {@code target} in {@code array}.
   *
   * @param array an array of {@code boolean} values, possibly empty
   * @param target a primitive {@code boolean} value
   * @return the greatest index {@code i} for which {@code array[i] == target}, or {@code -1} if no
   *     such index exists.
   */
  public static int lastIndexOf(boolean[] array, boolean target) {]]></codefragment>
   </duplication>
   <duplication lines="24" tokens="98">
      <file line="581"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/reflect/TypeToken.java"/>
      <file line="620"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/reflect/TypeToken.java"/>
      <codefragment><![CDATA[    return new Invokable.MethodInvokable<T>(method) {
      @Override
      Type getGenericReturnType() {
        return getCovariantTypeResolver().resolveType(super.getGenericReturnType());
      }

      @Override
      Type[] getGenericParameterTypes() {
        return getInvariantTypeResolver().resolveTypesInPlace(super.getGenericParameterTypes());
      }

      @Override
      Type[] getGenericExceptionTypes() {
        return getCovariantTypeResolver().resolveTypesInPlace(super.getGenericExceptionTypes());
      }

      @Override
      public TypeToken<T> getOwnerType() {
        return TypeToken.this;
      }

      @Override
      public String toString() {
        return getOwnerType() + "." + super.toString();]]></codefragment>
   </duplication>
   <duplication lines="15" tokens="96">
      <file line="824"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Sets.java"/>
      <file line="895"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Sets.java"/>
      <codefragment><![CDATA[  public static <E> SetView<E> intersection(final Set<E> set1, final Set<?> set2) {
    checkNotNull(set1, "set1");
    checkNotNull(set2, "set2");

    return new SetView<E>() {
      @Override
      public UnmodifiableIterator<E> iterator() {
        return new AbstractIterator<E>() {
          final Iterator<E> itr = set1.iterator();

          @Override
          protected E computeNext() {
            while (itr.hasNext()) {
              E e = itr.next();
              if (set2.contains(e)) {]]></codefragment>
   </duplication>
   <duplication lines="15" tokens="95">
      <file line="1483"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1603"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1650"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1693"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[        AtomicReferenceArray<E> table = this.table;
        int index = hash & (table.length() - 1);
        E first = table.get(index);

        // Look for an existing entry.
        for (E e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {
            // We found an existing entry.

            V entryValue = e.getValue();

            if (entryValue == null) {]]></codefragment>
   </duplication>
   <duplication lines="30" tokens="94">
      <file line="952"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="1239"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[    }

    // The code below is exactly the same for each entry type.

    final int hash;
    final @Nullable ReferenceEntry<K, V> next;
    volatile ValueReference<K, V> valueReference = unset();

    @Override
    public ValueReference<K, V> getValueReference() {
      return valueReference;
    }

    @Override
    public void setValueReference(ValueReference<K, V> valueReference) {
      this.valueReference = valueReference;
    }

    @Override
    public int getHash() {
      return hash;
    }

    @Override
    public ReferenceEntry<K, V> getNext() {
      return next;
    }
  }

  static final class StrongAccessEntry<K, V> extends StrongEntry<K, V> {]]></codefragment>
   </duplication>
   <duplication lines="9" tokens="93">
      <file line="2095"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2384"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
        int index = hash & (table.length() - 1);
        ReferenceEntry<K, V> first = table.get(index);

        for (e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {]]></codefragment>
   </duplication>
   <duplication lines="19" tokens="93">
      <file line="470"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/UnsignedBytes.java"/>
      <file line="230"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/UnsignedInts.java"/>
      <file line="196"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/UnsignedLongs.java"/>
      <codefragment><![CDATA[  public static void sort(byte[] array, int fromIndex, int toIndex) {
    checkNotNull(array);
    checkPositionIndexes(fromIndex, toIndex, array.length);
    for (int i = fromIndex; i < toIndex; i++) {
      array[i] = flip(array[i]);
    }
    Arrays.sort(array, fromIndex, toIndex);
    for (int i = fromIndex; i < toIndex; i++) {
      array[i] = flip(array[i]);
    }
  }

  /**
   * Sorts the elements of {@code array} in descending order, interpreting them as unsigned 8-bit
   * integers.
   *
   * @since 23.1
   */
  public static void sortDescending(byte[] array) {]]></codefragment>
   </duplication>
   <duplication lines="13" tokens="92">
      <file line="1483"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1603"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1650"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1733"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[        AtomicReferenceArray<E> table = this.table;
        int index = hash & (table.length() - 1);
        E first = table.get(index);

        // Look for an existing entry.
        for (E e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {
            // We found an existing entry.

            V entryValue = e.getValue();]]></codefragment>
   </duplication>
   <duplication lines="10" tokens="92">
      <file line="1692"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1732"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1847"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[        int newCount = this.count - 1;
        AtomicReferenceArray<E> table = this.table;
        int index = hash & (table.length() - 1);
        E first = table.get(index);

        for (E e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {]]></codefragment>
   </duplication>
   <duplication lines="22" tokens="91">
      <file line="80"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/AbstractBaseGraph.java"/>
      <file line="85"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/AbstractNetwork.java"/>
      <codefragment><![CDATA[        throw new UnsupportedOperationException();
      }

      // Mostly safe: We check contains(u) before calling successors(u), so we perform unsafe
      // operations only in weird cases like checking for an EndpointPair<ArrayList> in a
      // Graph<LinkedList>.
      @SuppressWarnings("unchecked")
      @Override
      public boolean contains(@Nullable Object obj) {
        if (!(obj instanceof EndpointPair)) {
          return false;
        }
        EndpointPair<?> endpointPair = (EndpointPair<?>) obj;
        return isOrderingCompatible(endpointPair)
            && nodes().contains(endpointPair.nodeU())
            && successors((N) endpointPair.nodeU()).contains(endpointPair.nodeV());
      }
    };
  }

  @Override
  public Set<EndpointPair<N>> incidentEdges(N node) {]]></codefragment>
   </duplication>
   <duplication lines="24" tokens="90">
      <file line="265"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Graphs.java"/>
      <file line="310"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Graphs.java"/>
      <file line="373"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Graphs.java"/>
      <codefragment><![CDATA[    }

    @Override
    public Set<N> predecessors(N node) {
      return delegate().successors(node); // transpose
    }

    @Override
    public Set<N> successors(N node) {
      return delegate().predecessors(node); // transpose
    }

    @Override
    public int inDegree(N node) {
      return delegate().outDegree(node); // transpose
    }

    @Override
    public int outDegree(N node) {
      return delegate().inDegree(node); // transpose
    }

    @Override
    public boolean hasEdgeConnecting(N nodeU, N nodeV) {]]></codefragment>
   </duplication>
   <duplication lines="18" tokens="89">
      <file line="407"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multisets.java"/>
      <file line="535"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multisets.java"/>
      <codefragment><![CDATA[  public static <E> Multiset<E> union(
      final Multiset<? extends E> multiset1, final Multiset<? extends E> multiset2) {
    checkNotNull(multiset1);
    checkNotNull(multiset2);

    return new ViewMultiset<E>() {
      @Override
      public boolean contains(@Nullable Object element) {
        return multiset1.contains(element) || multiset2.contains(element);
      }

      @Override
      public boolean isEmpty() {
        return multiset1.isEmpty() && multiset2.isEmpty();
      }

      @Override
      public int count(Object element) {]]></codefragment>
   </duplication>
   <duplication lines="19" tokens="89">
      <file line="556"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableIntArray.java"/>
      <file line="558"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableLongArray.java"/>
      <codefragment><![CDATA[    ImmutableIntArray that = (ImmutableIntArray) object;
    if (this.length() != that.length()) {
      return false;
    }
    for (int i = 0; i < length(); i++) {
      if (this.get(i) != that.get(i)) {
        return false;
      }
    }
    return true;
  }

  /** Returns an unspecified hash code for the contents of this immutable array. */
  @Override
  public int hashCode() {
    int hash = 1;
    for (int i = start; i < end; i++) {
      hash *= 31;
      hash += Ints.hashCode(array[i]);]]></codefragment>
   </duplication>
   <duplication lines="25" tokens="88">
      <file line="437"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/Stats.java"/>
      <file line="461"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/Stats.java"/>
      <codefragment><![CDATA[  public static double meanOf(double... values) {
    checkArgument(values.length > 0);
    double mean = values[0];
    for (int index = 1; index < values.length; index++) {
      double value = values[index];
      if (isFinite(value) && isFinite(mean)) {
        // Art of Computer Programming vol. 2, Knuth, 4.2.2, (15)
        mean += (value - mean) / (index + 1);
      } else {
        mean = calculateNewMeanNonFinite(mean, value);
      }
    }
    return mean;
  }

  /**
   * Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of the
   * values. The count must be non-zero.
   *
   * <p>The definition of the mean is the same as {@link Stats#mean}.
   *
   * @param values a series of values
   * @throws IllegalArgumentException if the dataset is empty
   */
  public static double meanOf(int... values) {]]></codefragment>
   </duplication>
   <duplication lines="14" tokens="88">
      <file line="346"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Bytes.java"/>
      <file line="671"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Ints.java"/>
      <codefragment><![CDATA[        result = 31 * result + Bytes.hashCode(array[i]);
      }
      return result;
    }

    @Override
    public String toString() {
      StringBuilder builder = new StringBuilder(size() * 5);
      builder.append('[').append(array[start]);
      for (int i = start + 1; i < end; i++) {
        builder.append(", ").append(array[i]);
      }
      return builder.append(']').toString();
    }]]></codefragment>
   </duplication>
   <duplication lines="14" tokens="88">
      <file line="627"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Doubles.java"/>
      <file line="613"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Floats.java"/>
      <codefragment><![CDATA[        result = 31 * result + Doubles.hashCode(array[i]);
      }
      return result;
    }

    @Override
    public String toString() {
      StringBuilder builder = new StringBuilder(size() * 12);
      builder.append('[').append(array[start]);
      for (int i = start + 1; i < end; i++) {
        builder.append(", ").append(array[i]);
      }
      return builder.append(']').toString();
    }]]></codefragment>
   </duplication>
   <duplication lines="26" tokens="88">
      <file line="165"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/UnsignedInts.java"/>
      <file line="130"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/UnsignedLongs.java"/>
      <codefragment><![CDATA[  public static String join(String separator, int... array) {
    checkNotNull(separator);
    if (array.length == 0) {
      return "";
    }

    // For pre-sizing a builder, just get the right order of magnitude
    StringBuilder builder = new StringBuilder(array.length * 5);
    builder.append(toString(array[0]));
    for (int i = 1; i < array.length; i++) {
      builder.append(separator).append(toString(array[i]));
    }
    return builder.toString();
  }

  /**
   * Returns a comparator that compares two arrays of unsigned {@code int} values <a
   * href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographically</a>. That is, it
   * compares, using {@link #compare(int, int)}), the first pair of values that follow any common
   * prefix, or when one array is a prefix of the other, treats the shorter array as the lesser. For
   * example, {@code [] < [1] < [1, 2] < [2] < [1 << 31]}.
   *
   * <p>The returned comparator is inconsistent with {@link Object#equals(Object)} (since arrays
   * support only identity equality), but it is consistent with {@link Arrays#equals(int[], int[])}.
   */
  public static Comparator<int[]> lexicographicalComparator() {]]></codefragment>
   </duplication>
   <duplication lines="13" tokens="87">
      <file line="498"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multisets.java"/>
      <file line="646"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multisets.java"/>
      <codefragment><![CDATA[      }

      @Override
      Iterator<Entry<E>> entryIterator() {
        final Iterator<Entry<E>> iterator1 = multiset1.entrySet().iterator();
        // TODO(lowasser): consider making the entries live views
        return new AbstractIterator<Entry<E>>() {
          @Override
          protected Entry<E> computeNext() {
            while (iterator1.hasNext()) {
              Entry<E> entry1 = iterator1.next();
              E element = entry1.getElement();
              int count = Math.min(entry1.getCount(), multiset2.count(element));]]></codefragment>
   </duplication>
   <duplication lines="4" tokens="86">
      <file line="66"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Tables.java"/>
      <file line="95"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Tables.java"/>
      <codefragment><![CDATA[  public static <T, R, C, V, I extends Table<R, C, V>> Collector<T, ?, I> toTable(
      java.util.function.Function<? super T, ? extends R> rowFunction,
      java.util.function.Function<? super T, ? extends C> columnFunction,
      java.util.function.Function<? super T, ? extends V> valueFunction,]]></codefragment>
   </duplication>
   <duplication lines="27" tokens="85">
      <file line="804"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashMap.java"/>
      <file line="530"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashSet.java"/>
      <codefragment><![CDATA[  }

  /**
   * Ensures that this {@code CompactHashMap} has the smallest representation in memory, given its
   * current size.
   */
  public void trimToSize() {
    if (needsAllocArrays()) {
      return;
    }
    int size = this.size;
    if (size < entries.length) {
      resizeEntries(size);
    }
    int minimumTableSize = Hashing.closedTableSize(size, LOAD_FACTOR);
    if (minimumTableSize < table.length) {
      resizeTable(minimumTableSize);
    }
  }

  @Override
  public void clear() {
    if (needsAllocArrays()) {
      return;
    }
    modCount++;
    Arrays.fill(keys, 0, size, null);]]></codefragment>
   </duplication>
   <duplication lines="24" tokens="85">
      <file line="504"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeRangeMap.java"/>
      <file line="682"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeRangeMap.java"/>
      <codefragment><![CDATA[              return endOfData();
            }
          };
        }
      };
    }

    @Override
    public boolean equals(@Nullable Object o) {
      if (o instanceof RangeMap) {
        RangeMap<?, ?> rangeMap = (RangeMap<?, ?>) o;
        return asMapOfRanges().equals(rangeMap.asMapOfRanges());
      }
      return false;
    }

    @Override
    public int hashCode() {
      return asMapOfRanges().hashCode();
    }

    @Override
    public String toString() {
      return asMapOfRanges().toString();]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="85">
      <file line="104"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/DirectedGraphConnections.java"/>
      <file line="136"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/DirectedGraphConnections.java"/>
      <codefragment><![CDATA[  public Set<N> predecessors() {
    return new AbstractSet<N>() {
      @Override
      public UnmodifiableIterator<N> iterator() {
        final Iterator<Entry<N, Object>> entries = adjacentNodeValues.entrySet().iterator();
        return new AbstractIterator<N>() {
          @Override
          protected N computeNext() {
            while (entries.hasNext()) {
              Entry<N, Object> entry = entries.next();
              if (isPredecessor(entry.getValue())) {]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="84">
      <file line="295"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/Striped64.java"/>
      <file line="295"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/Striped64.java"/>
      <file line="1188"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/AbstractFuture.java"/>
      <codefragment><![CDATA[          new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {
            @Override
            public sun.misc.Unsafe run() throws Exception {
              Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;
              for (java.lang.reflect.Field f : k.getDeclaredFields()) {
                f.setAccessible(true);
                Object x = f.get(null);
                if (k.isInstance(x)) return k.cast(x);]]></codefragment>
   </duplication>
   <duplication lines="10" tokens="84">
      <file line="1483"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1603"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1650"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1693"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1733"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1848"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1884"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[        AtomicReferenceArray<E> table = this.table;
        int index = hash & (table.length() - 1);
        E first = table.get(index);

        // Look for an existing entry.
        for (E e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="84">
      <file line="2897"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Maps.java"/>
      <file line="2911"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Maps.java"/>
      <codefragment><![CDATA[    static <K, V> boolean removeAllKeys(
        Map<K, V> map, Predicate<? super Entry<K, V>> entryPredicate, Collection<?> keyCollection) {
      Iterator<Entry<K, V>> entryItr = map.entrySet().iterator();
      boolean result = false;
      while (entryItr.hasNext()) {
        Entry<K, V> entry = entryItr.next();
        if (entryPredicate.apply(entry) && keyCollection.contains(entry.getKey())) {]]></codefragment>
   </duplication>
   <duplication lines="29" tokens="83">
      <file line="4387"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2575"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[        V value = getLiveValue(entry, now);
        if (value != null) {
          nextExternal = new WriteThroughEntry(key, value);
          return true;
        } else {
          // Skip stale entry.
          return false;
        }
      } finally {
        currentSegment.postReadCleanup();
      }
    }

    @Override
    public boolean hasNext() {
      return nextExternal != null;
    }

    WriteThroughEntry nextEntry() {
      if (nextExternal == null) {
        throw new NoSuchElementException();
      }
      lastReturned = nextExternal;
      advance();
      return lastReturned;
    }

    @Override
    public void remove() {]]></codefragment>
   </duplication>
   <duplication lines="14" tokens="83">
      <file line="437"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/Stats.java"/>
      <file line="461"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/Stats.java"/>
      <file line="486"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/Stats.java"/>
      <codefragment><![CDATA[  public static double meanOf(double... values) {
    checkArgument(values.length > 0);
    double mean = values[0];
    for (int index = 1; index < values.length; index++) {
      double value = values[index];
      if (isFinite(value) && isFinite(mean)) {
        // Art of Computer Programming vol. 2, Knuth, 4.2.2, (15)
        mean += (value - mean) / (index + 1);
      } else {
        mean = calculateNewMeanNonFinite(mean, value);
      }
    }
    return mean;
  }]]></codefragment>
   </duplication>
   <duplication lines="10" tokens="82">
      <file line="126"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableListMultimap.java"/>
      <file line="139"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSetMultimap.java"/>
      <codefragment><![CDATA[      Collector<T, ?, ImmutableListMultimap<K, V>> flatteningToImmutableListMultimap(
          Function<? super T, ? extends K> keyFunction,
          Function<? super T, ? extends Stream<? extends V>> valuesFunction) {
    checkNotNull(keyFunction);
    checkNotNull(valuesFunction);
    return Collectors.collectingAndThen(
        Multimaps.flatteningToMultimap(
            input -> checkNotNull(keyFunction.apply(input)),
            input -> valuesFunction.apply(input).peek(Preconditions::checkNotNull),
            MultimapBuilder.linkedHashKeys().arrayListValues()::<K, V>build),]]></codefragment>
   </duplication>
   <duplication lines="29" tokens="82">
      <file line="348"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Doubles.java"/>
      <file line="343"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Floats.java"/>
      <codefragment><![CDATA[  public static String join(String separator, double... array) {
    checkNotNull(separator);
    if (array.length == 0) {
      return "";
    }

    // For pre-sizing a builder, just get the right order of magnitude
    StringBuilder builder = new StringBuilder(array.length * 12);
    builder.append(array[0]);
    for (int i = 1; i < array.length; i++) {
      builder.append(separator).append(array[i]);
    }
    return builder.toString();
  }

  /**
   * Returns a comparator that compares two {@code double} arrays <a
   * href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographically</a>. That is, it
   * compares, using {@link #compare(double, double)}), the first pair of values that follow any
   * common prefix, or when one array is a prefix of the other, treats the shorter array as the
   * lesser. For example, {@code [] < [1.0] < [1.0, 2.0] < [2.0]}.
   *
   * <p>The returned comparator is inconsistent with {@link Object#equals(Object)} (since arrays
   * support only identity equality), but it is consistent with {@link Arrays#equals(double[],
   * double[])}.
   *
   * @since 2.0
   */
  public static Comparator<double[]> lexicographicalComparator() {]]></codefragment>
   </duplication>
   <duplication lines="28" tokens="82">
      <file line="403"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Ints.java"/>
      <file line="143"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/SignedBytes.java"/>
      <codefragment><![CDATA[  public static String join(String separator, int... array) {
    checkNotNull(separator);
    if (array.length == 0) {
      return "";
    }

    // For pre-sizing a builder, just get the right order of magnitude
    StringBuilder builder = new StringBuilder(array.length * 5);
    builder.append(array[0]);
    for (int i = 1; i < array.length; i++) {
      builder.append(separator).append(array[i]);
    }
    return builder.toString();
  }

  /**
   * Returns a comparator that compares two {@code int} arrays <a
   * href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographically</a>. That is, it
   * compares, using {@link #compare(int, int)}), the first pair of values that follow any common
   * prefix, or when one array is a prefix of the other, treats the shorter array as the lesser. For
   * example, {@code [] < [1] < [1, 2] < [2]}.
   *
   * <p>The returned comparator is inconsistent with {@link Object#equals(Object)} (since arrays
   * support only identity equality), but it is consistent with {@link Arrays#equals(int[], int[])}.
   *
   * @since 2.0
   */
  public static Comparator<int[]> lexicographicalComparator() {]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="81">
      <file line="482"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="535"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        return new StrongAccessWriteEntry<>(key, hash, next);
      }

      @Override
      <K, V> ReferenceEntry<K, V> copyEntry(
          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);
        copyAccessEntry(original, newEntry);
        copyWriteEntry(original, newEntry);
        return newEntry;
      }
    },]]></codefragment>
   </duplication>
   <duplication lines="9" tokens="81">
      <file line="352"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableBiMap.java"/>
      <file line="448"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableMap.java"/>
      <codefragment><![CDATA[  public static <K, V> ImmutableBiMap<K, V> copyOf(
      Iterable<? extends Entry<? extends K, ? extends V>> entries) {
    @SuppressWarnings("unchecked") // we'll only be using getKey and getValue, which are covariant
    Entry<K, V>[] entryArray = (Entry<K, V>[]) Iterables.toArray(entries, EMPTY_ENTRY_ARRAY);
    switch (entryArray.length) {
      case 0:
        return of();
      case 1:
        Entry<K, V> entry = entryArray[0];]]></codefragment>
   </duplication>
   <duplication lines="18" tokens="81">
      <file line="366"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Traverser.java"/>
      <file line="532"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Traverser.java"/>
      <codefragment><![CDATA[          return new DepthFirstIterator(startNodes, Order.PREORDER);
        }
      };
    }

    @Override
    public Iterable<N> depthFirstPostOrder(final N startNode) {
      checkNotNull(startNode);
      return depthFirstPostOrder(ImmutableSet.of(startNode));
    }

    @Override
    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {
      checkNotNull(startNodes);
      if (Iterables.isEmpty(startNodes)) {
        return ImmutableSet.of();
      }
      for (N startNode : startNodes) {]]></codefragment>
   </duplication>
   <duplication lines="16" tokens="80">
      <file line="418"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="515"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[            K, V, StrongKeyStrongValueEntry<K, V>, StrongKeyStrongValueSegment<K, V>> {
      private static final Helper<?, ?> INSTANCE = new Helper<>();

      @SuppressWarnings("unchecked")
      static <K, V> Helper<K, V> instance() {
        return (Helper<K, V>) INSTANCE;
      }

      @Override
      public Strength keyStrength() {
        return Strength.STRONG;
      }

      @Override
      public Strength valueStrength() {
        return Strength.STRONG;]]></codefragment>
   </duplication>
   <duplication lines="16" tokens="80">
      <file line="784"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="886"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[            K, V, WeakKeyStrongValueEntry<K, V>, WeakKeyStrongValueSegment<K, V>> {
      private static final Helper<?, ?> INSTANCE = new Helper<>();

      @SuppressWarnings("unchecked")
      static <K, V> Helper<K, V> instance() {
        return (Helper<K, V>) INSTANCE;
      }

      @Override
      public Strength keyStrength() {
        return Strength.WEAK;
      }

      @Override
      public Strength valueStrength() {
        return Strength.STRONG;]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="80">
      <file line="365"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Streams.java"/>
      <file line="447"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Streams.java"/>
      <file line="526"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Streams.java"/>
      <file line="606"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Streams.java"/>
      <codefragment><![CDATA[      Iterator<T> fromIterator = Spliterators.iterator(fromSpliterator);
      return StreamSupport.stream(
              new AbstractSpliterator<R>(
                  fromSpliterator.estimateSize(),
                  fromSpliterator.characteristics() & (Spliterator.ORDERED | Spliterator.SIZED)) {
                long index = 0;

                @Override
                public boolean tryAdvance(Consumer<? super R> action) {
                  if (fromIterator.hasNext()) {
                    action.accept(function.apply(fromIterator.next(), index++));]]></codefragment>
   </duplication>
   <duplication lines="16" tokens="79">
      <file line="322"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Traverser.java"/>
      <file line="488"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Traverser.java"/>
      <codefragment><![CDATA[      this.graph = checkNotNull(graph);
    }

    @Override
    public Iterable<N> breadthFirst(final N startNode) {
      checkNotNull(startNode);
      return breadthFirst(ImmutableSet.of(startNode));
    }

    @Override
    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {
      checkNotNull(startNodes);
      if (Iterables.isEmpty(startNodes)) {
        return ImmutableSet.of();
      }
      for (N startNode : startNodes) {]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="78">
      <file line="505"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="535"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        return new WeakAccessEntry<>(segment.keyReferenceQueue, key, hash, next);
      }

      @Override
      <K, V> ReferenceEntry<K, V> copyEntry(
          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);
        copyAccessEntry(original, newEntry);]]></codefragment>
   </duplication>
   <duplication lines="15" tokens="78">
      <file line="1587"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="1609"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[    WeightedWeakValueReference(
        ReferenceQueue<V> queue, V referent, ReferenceEntry<K, V> entry, int weight) {
      super(queue, referent, entry);
      this.weight = weight;
    }

    @Override
    public int getWeight() {
      return weight;
    }

    @Override
    public ValueReference<K, V> copyFor(
        ReferenceQueue<V> queue, V value, ReferenceEntry<K, V> entry) {
      return new WeightedWeakValueReference<>(queue, value, entry, weight);]]></codefragment>
   </duplication>
   <duplication lines="23" tokens="78">
      <file line="101"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableMapValues.java"/>
      <file line="285"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/RegularImmutableMap.java"/>
      <codefragment><![CDATA[  }

  @GwtIncompatible // serialization
  @Override
  Object writeReplace() {
    return new SerializedForm<V>(map);
  }

  @GwtIncompatible // serialization
  private static class SerializedForm<V> implements Serializable {
    final ImmutableMap<?, V> map;

    SerializedForm(ImmutableMap<?, V> map) {
      this.map = map;
    }

    Object readResolve() {
      return map.values();
    }

    private static final long serialVersionUID = 0;
  }
}]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="78">
      <file line="781"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeMultiset.java"/>
      <file line="802"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeMultiset.java"/>
      <codefragment><![CDATA[        left = initLeft.setCount(comparator, e, expectedCount, newCount, result);

        if (result[0] == expectedCount) {
          if (newCount == 0 && result[0] != 0) {
            this.distinctElements--;
          } else if (newCount > 0 && result[0] == 0) {
            this.distinctElements++;
          }
          this.totalCount += newCount - result[0];
        }
        return rebalance();
      } else if (cmp > 0) {]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="77">
      <file line="831"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashMap.java"/>
      <file line="556"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashSet.java"/>
      <codefragment><![CDATA[    Arrays.fill(values, 0, size, null);
    Arrays.fill(table, UNSET);
    Arrays.fill(entries, 0, size, UNSET);
    this.size = 0;
  }

  private void writeObject(ObjectOutputStream stream) throws IOException {
    stream.defaultWriteObject();
    stream.writeInt(size);
    for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {
      stream.writeObject(keys[i]);]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="77">
      <file line="74"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Comparators.java"/>
      <file line="96"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Comparators.java"/>
      <codefragment><![CDATA[  public static <T> boolean isInOrder(Iterable<? extends T> iterable, Comparator<T> comparator) {
    checkNotNull(comparator);
    Iterator<? extends T> it = iterable.iterator();
    if (it.hasNext()) {
      T prev = it.next();
      while (it.hasNext()) {
        T next = it.next();
        if (comparator.compare(prev, next) > 0) {]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="76">
      <file line="452"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="505"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        return new StrongAccessEntry<>(key, hash, next);
      }

      @Override
      <K, V> ReferenceEntry<K, V> copyEntry(
          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);
        copyAccessEntry(original, newEntry);
        return newEntry;
      }
    },]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="76">
      <file line="467"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="520"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        return new StrongWriteEntry<>(key, hash, next);
      }

      @Override
      <K, V> ReferenceEntry<K, V> copyEntry(
          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);
        copyWriteEntry(original, newEntry);
        return newEntry;
      }
    },]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="76">
      <file line="238"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <file line="428"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <codefragment><![CDATA[    protected Collection<V> createCollection() {
      return factory.get();
    }

    @Override
    <E> Collection<E> unmodifiableCollectionSubclass(Collection<E> collection) {
      if (collection instanceof NavigableSet) {
        return Sets.unmodifiableNavigableSet((NavigableSet<E>) collection);
      } else if (collection instanceof SortedSet) {
        return Collections.unmodifiableSortedSet((SortedSet<E>) collection);
      } else if (collection instanceof Set) {]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="76">
      <file line="602"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/LongMath.java"/>
      <file line="716"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/LongMath.java"/>
      <codefragment><![CDATA[  public static long checkedPow(long b, int k) {
    checkNonNegative("exponent", k);
    if (b >= -2 & b <= 2) {
      switch ((int) b) {
        case 0:
          return (k == 0) ? 1 : 0;
        case 1:
          return 1;
        case (-1):
          return ((k & 1) == 0) ? 1 : -1;
        case 2:]]></codefragment>
   </duplication>
   <duplication lines="22" tokens="75">
      <file line="291"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashMap.java"/>
      <file line="284"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashSet.java"/>
      <codefragment><![CDATA[  }

  /** Resizes the entries storage if necessary. */
  private void resizeMeMaybe(int newSize) {
    int entriesSize = entries.length;
    if (newSize > entriesSize) {
      int newCapacity = entriesSize + Math.max(1, entriesSize >>> 1);
      if (newCapacity < 0) {
        newCapacity = Integer.MAX_VALUE;
      }
      if (newCapacity != entriesSize) {
        resizeEntries(newCapacity);
      }
    }
  }

  /**
   * Resizes the internal entries array to the specified capacity, which may be greater or less than
   * the current capacity.
   */
  void resizeEntries(int newCapacity) {
    this.keys = Arrays.copyOf(keys, newCapacity);]]></codefragment>
   </duplication>
   <duplication lines="24" tokens="75">
      <file line="544"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Synchronized.java"/>
      <file line="737"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Synchronized.java"/>
      <file line="1210"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Synchronized.java"/>
      <codefragment><![CDATA[      }
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      synchronized (mutex) {
        return delegate().equals(o);
      }
    }

    @Override
    public int hashCode() {
      synchronized (mutex) {
        return delegate().hashCode();
      }
    }

    private static final long serialVersionUID = 0;
  }

  static <K, V> Multimap<K, V> multimap(Multimap<K, V> multimap, @Nullable Object mutex) {]]></codefragment>
   </duplication>
   <duplication lines="20" tokens="75">
      <file line="57"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/ForwardingGraph.java"/>
      <file line="65"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/ForwardingNetwork.java"/>
      <file line="60"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/ForwardingValueGraph.java"/>
      <codefragment><![CDATA[    return delegate().nodeOrder();
  }

  @Override
  public Set<N> adjacentNodes(N node) {
    return delegate().adjacentNodes(node);
  }

  @Override
  public Set<N> predecessors(N node) {
    return delegate().predecessors(node);
  }

  @Override
  public Set<N> successors(N node) {
    return delegate().successors(node);
  }

  @Override
  public int degree(N node) {]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="74">
      <file line="452"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="482"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        return new StrongAccessEntry<>(key, hash, next);
      }

      @Override
      <K, V> ReferenceEntry<K, V> copyEntry(
          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);
        copyAccessEntry(original, newEntry);]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="74">
      <file line="3312"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3388"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[      try {
        int newCount = this.count - 1;
        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
        int index = hash & (table.length() - 1);
        ReferenceEntry<K, V> first = table.get(index);

        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {]]></codefragment>
   </duplication>
   <duplication lines="15" tokens="74">
      <file line="377"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableCollection.java"/>
      <file line="304"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableDoubleArray.java"/>
      <file line="301"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableIntArray.java"/>
      <file line="303"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableLongArray.java"/>
      <codefragment><![CDATA[    static int expandedCapacity(int oldCapacity, int minCapacity) {
      if (minCapacity < 0) {
        throw new AssertionError("cannot store more than MAX_VALUE elements");
      }
      // careful of overflow!
      int newCapacity = oldCapacity + (oldCapacity >> 1) + 1;
      if (newCapacity < minCapacity) {
        newCapacity = Integer.highestOneBit(minCapacity - 1) << 1;
      }
      if (newCapacity < 0) {
        newCapacity = Integer.MAX_VALUE;
        // guaranteed to be >= newCapacity
      }
      return newCapacity;
    }]]></codefragment>
   </duplication>
   <duplication lines="9" tokens="74">
      <file line="2054"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="2187"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[    public WeakValueReference<K, V, StrongKeyWeakValueEntry<K, V>> newWeakValueReferenceForTesting(
        InternalEntry<K, V, ?> e, V value) {
      return new WeakValueReferenceImpl<>(queueForValues, value, castForTesting(e));
    }

    @Override
    public void setWeakValueReferenceForTesting(
        InternalEntry<K, V, ?> e,
        WeakValueReference<K, V, ? extends InternalEntry<K, V, ?>> valueReference) {]]></codefragment>
   </duplication>
   <duplication lines="21" tokens="74">
      <file line="1127"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Maps.java"/>
      <file line="1162"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Maps.java"/>
      <codefragment><![CDATA[      protected SortedSet<E> delegate() {
        return set;
      }

      @Override
      public boolean add(E element) {
        throw new UnsupportedOperationException();
      }

      @Override
      public boolean addAll(Collection<? extends E> es) {
        throw new UnsupportedOperationException();
      }

      @Override
      public SortedSet<E> headSet(E toElement) {
        return removeOnlySortedSet(super.headSet(toElement));
      }

      @Override
      public SortedSet<E> subSet(E fromElement, E toElement) {]]></codefragment>
   </duplication>
   <duplication lines="6" tokens="73">
      <file line="3037"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3083"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3389"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        int newCount = this.count - 1;
        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
        int index = hash & (table.length() - 1);
        ReferenceEntry<K, V> first = table.get(index);

        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {]]></codefragment>
   </duplication>
   <duplication lines="26" tokens="73">
      <file line="4417"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2605"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[      LocalCache.this.remove(lastReturned.getKey());
      lastReturned = null;
    }
  }

  final class KeyIterator extends HashIterator<K> {

    @Override
    public K next() {
      return nextEntry().getKey();
    }
  }

  final class ValueIterator extends HashIterator<V> {

    @Override
    public V next() {
      return nextEntry().getValue();
    }
  }

  /**
   * Custom Entry class used by EntryIterator.next(), that relays setValue changes to the underlying
   * map.
   */
  final class WriteThroughEntry implements Entry<K, V> {]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="73">
      <file line="355"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Traverser.java"/>
      <file line="378"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Traverser.java"/>
      <codefragment><![CDATA[    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {
      checkNotNull(startNodes);
      if (Iterables.isEmpty(startNodes)) {
        return ImmutableSet.of();
      }
      for (N startNode : startNodes) {
        checkThatNodeIsInGraph(startNode);
      }
      return new Iterable<N>() {
        @Override
        public Iterator<N> iterator() {
          return new DepthFirstIterator(startNodes, Order.PREORDER);]]></codefragment>
   </duplication>
   <duplication lines="20" tokens="73">
      <file line="162"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/IntMath.java"/>
      <file line="165"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/LongMath.java"/>
      <codefragment><![CDATA[    int floorPow = powersOf10[logFloor];
    switch (mode) {
      case UNNECESSARY:
        checkRoundingUnnecessary(x == floorPow);
        // fall through
      case FLOOR:
      case DOWN:
        return logFloor;
      case CEILING:
      case UP:
        return logFloor + lessThanBranchFree(floorPow, x);
      case HALF_DOWN:
      case HALF_UP:
      case HALF_EVEN:
        // sqrt(10) is irrational, so log10(x) - logFloor is never exactly 0.5
        return logFloor + lessThanBranchFree(halfPowersOf10[logFloor], x);
      default:
        throw new AssertionError();
    }
  }]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="72">
      <file line="505"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="520"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="535"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        return new WeakAccessEntry<>(segment.keyReferenceQueue, key, hash, next);
      }

      @Override
      <K, V> ReferenceEntry<K, V> copyEntry(
          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);]]></codefragment>
   </duplication>
   <duplication lines="19" tokens="72">
      <file line="174"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashMap.java"/>
      <file line="184"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashSet.java"/>
      <codefragment><![CDATA[    Preconditions.checkArgument(expectedSize >= 0, "Expected size must be non-negative");
    this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()
  }

  /** Returns whether arrays need to be allocated. */
  boolean needsAllocArrays() {
    return table == null;
  }

  /** Handle lazy allocation of arrays. */
  void allocArrays() {
    Preconditions.checkState(needsAllocArrays(), "Arrays already allocated");

    int expectedSize = modCount;
    int buckets = Hashing.closedTableSize(expectedSize, LOAD_FACTOR);
    this.table = newTable(buckets);

    this.entries = newEntries(expectedSize);
    this.keys = new Object[expectedSize];]]></codefragment>
   </duplication>
   <duplication lines="14" tokens="72">
      <file line="247"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableMultimap.java"/>
      <file line="306"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSetMultimap.java"/>
      <codefragment><![CDATA[    public Builder<K, V> putAll(Multimap<? extends K, ? extends V> multimap) {
      for (Entry<? extends K, ? extends Collection<? extends V>> entry :
          multimap.asMap().entrySet()) {
        putAll(entry.getKey(), entry.getValue());
      }
      return this;
    }

    /**
     * Specifies the ordering of the generated multimap's keys.
     *
     * @since 8.0
     */
    @CanIgnoreReturnValue]]></codefragment>
   </duplication>
   <duplication lines="19" tokens="72">
      <file line="719"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <file line="1154"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <codefragment><![CDATA[    }

    @Override
    public boolean put(K key, V value) {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean putAll(K key, Iterable<? extends V> values) {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean putAll(Multimap<? extends K, ? extends V> multimap) {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean remove(Object key, Object value) {]]></codefragment>
   </duplication>
   <duplication lines="16" tokens="72">
      <file line="449"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multisets.java"/>
      <file line="582"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multisets.java"/>
      <codefragment><![CDATA[              int count = Math.max(entry1.getCount(), multiset2.count(element));
              return immutableEntry(element, count);
            }
            while (iterator2.hasNext()) {
              Entry<? extends E> entry2 = iterator2.next();
              E element = entry2.getElement();
              if (!multiset1.contains(element)) {
                return immutableEntry(element, entry2.getCount());
              }
            }
            return endOfData();
          }
        };
      }
    };
  }]]></codefragment>
   </duplication>
   <duplication lines="9" tokens="72">
      <file line="150"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/Murmur3_32HashFunction.java"/>
      <file line="343"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/Murmur3_32HashFunction.java"/>
      <codefragment><![CDATA[      int len = 0;

      // This loop optimizes for pure ASCII.
      while (i + 4 <= utf16Length) {
        char c0 = input.charAt(i);
        char c1 = input.charAt(i + 1);
        char c2 = input.charAt(i + 2);
        char c3 = input.charAt(i + 3);
        if (c0 < 0x80 && c1 < 0x80 && c2 < 0x80 && c3 < 0x80) {]]></codefragment>
   </duplication>
   <duplication lines="14" tokens="72">
      <file line="592"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/IntMath.java"/>
      <file line="742"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/LongMath.java"/>
      <codefragment><![CDATA[    int limit = Integer.MAX_VALUE + ((b >>> Integer.SIZE - 1) & (k & 1));
    while (true) {
      switch (k) {
        case 0:
          return accum;
        case 1:
          return saturatedMultiply(accum, b);
        default:
          if ((k & 1) != 0) {
            accum = saturatedMultiply(accum, b);
          }
          k >>= 1;
          if (k > 0) {
            if (-FLOOR_SQRT_MAX_INT > b | b > FLOOR_SQRT_MAX_INT) {]]></codefragment>
   </duplication>
   <duplication lines="9" tokens="72">
      <file line="195"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/net/PercentEscaper.java"/>
      <file line="218"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/net/PercentEscaper.java"/>
      <codefragment><![CDATA[      dest[8] = UPPER_HEX_DIGITS[cp & 0xF];
      cp >>>= 4;
      dest[7] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];
      cp >>>= 2;
      dest[5] = UPPER_HEX_DIGITS[cp & 0xF];
      cp >>>= 4;
      dest[4] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];
      cp >>>= 2;
      dest[2] = UPPER_HEX_DIGITS[cp];]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="71">
      <file line="452"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="535"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        return new StrongAccessEntry<>(key, hash, next);
      }

      @Override
      <K, V> ReferenceEntry<K, V> copyEntry(
          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);
        copyAccessEntry(original, newEntry);]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="71">
      <file line="482"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="505"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        return new StrongAccessWriteEntry<>(key, hash, next);
      }

      @Override
      <K, V> ReferenceEntry<K, V> copyEntry(
          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);
        copyAccessEntry(original, newEntry);]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="71">
      <file line="2088"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3032"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3078"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[      lock();
      try {
        // re-read ticker once inside the lock
        long now = map.ticker.read();
        preWriteCleanup(now);

        int newCount = this.count - 1;
        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
        int index = hash & (table.length() - 1);
        ReferenceEntry<K, V> first = table.get(index);

        for (e = first; e != null; e = e.getNext()) {]]></codefragment>
   </duplication>
   <duplication lines="21" tokens="71">
      <file line="452"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashMap.java"/>
      <file line="421"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashSet.java"/>
      <codefragment><![CDATA[      values[dstIndex] = null;
      entries[dstIndex] = UNSET;
    }
  }

  int firstEntryIndex() {
    return isEmpty() ? -1 : 0;
  }

  int getSuccessor(int entryIndex) {
    return (entryIndex + 1 < size) ? entryIndex + 1 : -1;
  }

  /**
   * Updates the index an iterator is pointing to after a call to remove: returns the index of the
   * entry that should be looked at after a removal on indexRemoved, with indexBeforeRemove as the
   * index that *was* the next entry that would be looked at.
   */
  int adjustAfterRemove(int indexBeforeRemove, @SuppressWarnings("unused") int indexRemoved) {
    return indexBeforeRemove - 1;
  }]]></codefragment>
   </duplication>
   <duplication lines="35" tokens="71">
      <file line="178"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableBiMap.java"/>
      <file line="255"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSetMultimap.java"/>
      <file line="460"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedMap.java"/>
      <codefragment><![CDATA[      super(size);
    }

    /**
     * Associates {@code key} with {@code value} in the built bimap. Duplicate keys or values are
     * not allowed, and will cause {@link #build} to fail.
     */
    @CanIgnoreReturnValue
    @Override
    public Builder<K, V> put(K key, V value) {
      super.put(key, value);
      return this;
    }

    /**
     * Adds the given {@code entry} to the bimap. Duplicate keys or values are not allowed, and will
     * cause {@link #build} to fail.
     *
     * @since 19.0
     */
    @CanIgnoreReturnValue
    @Override
    public Builder<K, V> put(Entry<? extends K, ? extends V> entry) {
      super.put(entry);
      return this;
    }

    /**
     * Associates all of the given map's keys and values in the built bimap. Duplicate keys or
     * values are not allowed, and will cause {@link #build} to fail.
     *
     * @throws NullPointerException if any key or value in {@code map} is null
     */
    @CanIgnoreReturnValue
    @Override]]></codefragment>
   </duplication>
   <duplication lines="13" tokens="71">
      <file line="171"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableRangeMap.java"/>
      <file line="188"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableRangeMap.java"/>
      <codefragment><![CDATA[  public @Nullable V get(K key) {
    int index =
        SortedLists.binarySearch(
            ranges,
            Range.<K>lowerBoundFn(),
            Cut.belowValue(key),
            KeyPresentBehavior.ANY_PRESENT,
            KeyAbsentBehavior.NEXT_LOWER);
    if (index == -1) {
      return null;
    } else {
      Range<K> range = ranges.get(index);
      return range.contains(key) ? values.get(index) : null;]]></codefragment>
   </duplication>
   <duplication lines="27" tokens="70">
      <file line="1639"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="1041"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[    }
  }

  /**
   * Applies a supplemental hash function to a given hash code, which defends against poor quality
   * hash functions. This is critical when the concurrent hash map uses power-of-two length hash
   * tables, that otherwise encounter collisions for hash codes that do not differ in lower or upper
   * bits.
   *
   * @param h hash code
   */
  static int rehash(int h) {
    // Spread bits to regularize both segment and index locations,
    // using variant of single-word Wang/Jenkins hash.
    // TODO(kevinb): use Hashing/move this to Hashing?
    h += (h << 15) ^ 0xffffcd7d;
    h ^= (h >>> 10);
    h += (h << 3);
    h ^= (h >>> 6);
    h += (h << 2) + (h << 14);
    return h ^ (h >>> 16);
  }

  /**
   * This method is a convenience for testing. Code should call {@link Segment#newEntry} directly.
   */
  @VisibleForTesting]]></codefragment>
   </duplication>
   <duplication lines="34" tokens="70">
      <file line="179"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableBiMap.java"/>
      <file line="227"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableListMultimap.java"/>
      <file line="461"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedMap.java"/>
      <codefragment><![CDATA[    }

    /**
     * Associates {@code key} with {@code value} in the built bimap. Duplicate keys or values are
     * not allowed, and will cause {@link #build} to fail.
     */
    @CanIgnoreReturnValue
    @Override
    public Builder<K, V> put(K key, V value) {
      super.put(key, value);
      return this;
    }

    /**
     * Adds the given {@code entry} to the bimap. Duplicate keys or values are not allowed, and will
     * cause {@link #build} to fail.
     *
     * @since 19.0
     */
    @CanIgnoreReturnValue
    @Override
    public Builder<K, V> put(Entry<? extends K, ? extends V> entry) {
      super.put(entry);
      return this;
    }

    /**
     * Associates all of the given map's keys and values in the built bimap. Duplicate keys or
     * values are not allowed, and will cause {@link #build} to fail.
     *
     * @throws NullPointerException if any key or value in {@code map} is null
     */
    @CanIgnoreReturnValue
    @Override]]></codefragment>
   </duplication>
   <duplication lines="23" tokens="70">
      <file line="265"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Synchronized.java"/>
      <file line="440"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Synchronized.java"/>
      <codefragment><![CDATA[    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      synchronized (mutex) {
        return delegate().equals(o);
      }
    }

    @Override
    public int hashCode() {
      synchronized (mutex) {
        return delegate().hashCode();
      }
    }

    private static final long serialVersionUID = 0;
  }

  private static <E> SortedSet<E> sortedSet(SortedSet<E> set, @Nullable Object mutex) {]]></codefragment>
   </duplication>
   <duplication lines="17" tokens="70">
      <file line="155"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/escape/CharEscaper.java"/>
      <file line="285"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/escape/UnicodeEscaper.java"/>
      <codefragment><![CDATA[    return new String(dest, 0, destIndex);
  }

  /**
   * Helper method to grow the character buffer as needed, this only happens once in a while so it's
   * ok if it's in a method call. If the index passed in is 0 then no copying will be done.
   */
  private static char[] growBuffer(char[] dest, int index, int size) {
    if (size < 0) { // overflow - should be OutOfMemoryError but GWT/j2cl don't support it
      throw new AssertionError("Cannot increase internal buffer any further");
    }
    char[] copy = new char[size];
    if (index > 0) {
      System.arraycopy(dest, 0, copy, 0, index);
    }
    return copy;
  }]]></codefragment>
   </duplication>
   <duplication lines="29" tokens="70">
      <file line="525"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableIntArray.java"/>
      <file line="527"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableLongArray.java"/>
      <codefragment><![CDATA[        if (!(element instanceof Integer) || parent.array[i++] != (Integer) element) {
          return false;
        }
      }
      return true;
    }

    // Because we happen to use the same formula. If that changes, just don't override this.
    @Override
    public int hashCode() {
      return parent.hashCode();
    }

    @Override
    public String toString() {
      return parent.toString();
    }
  }

  /**
   * Returns {@code true} if {@code object} is an {@code ImmutableIntArray} containing the same
   * values as this one, in the same order.
   */
  @Override
  public boolean equals(@Nullable Object object) {
    if (object == this) {
      return true;
    }
    if (!(object instanceof ImmutableIntArray)) {]]></codefragment>
   </duplication>
   <duplication lines="15" tokens="69">
      <file line="2669"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="1389"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[      for (ReferenceEntry<K, V> e = getFirst(hash); e != null; e = e.getNext()) {
        if (e.getHash() != hash) {
          continue;
        }

        K entryKey = e.getKey();
        if (entryKey == null) {
          tryDrainReferenceQueues();
          continue;
        }

        if (map.keyEquivalence.equivalent(key, entryKey)) {
          return e;
        }
      }]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="69">
      <file line="45"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/AbstractMapEntry.java"/>
      <file line="91"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ForwardingMapEntry.java"/>
      <codefragment><![CDATA[  public boolean equals(@Nullable Object object) {
    if (object instanceof Entry) {
      Entry<?, ?> that = (Entry<?, ?>) object;
      return Objects.equal(this.getKey(), that.getKey())
          && Objects.equal(this.getValue(), that.getValue());
    }
    return false;
  }]]></codefragment>
   </duplication>
   <duplication lines="18" tokens="69">
      <file line="147"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ArrayListMultimap.java"/>
      <file line="117"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/HashMultimap.java"/>
      <codefragment><![CDATA[  }

  /**
   * @serialData expectedValuesPerKey, number of distinct keys, and then for each distinct key: the
   *     key, number of values for that key, and the key's values
   */
  @GwtIncompatible // java.io.ObjectOutputStream
  private void writeObject(ObjectOutputStream stream) throws IOException {
    stream.defaultWriteObject();
    Serialization.writeMultimap(this, stream);
  }

  @GwtIncompatible // java.io.ObjectOutputStream
  private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
    stream.defaultReadObject();
    expectedValuesPerKey = DEFAULT_VALUES_PER_KEY;
    int distinctKeys = Serialization.readCount(stream);
    Map<K, Collection<V>> map = Maps.newHashMap();]]></codefragment>
   </duplication>
   <duplication lines="13" tokens="69">
      <file line="842"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashMap.java"/>
      <file line="566"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashSet.java"/>
      <codefragment><![CDATA[      stream.writeObject(values[i]);
    }
  }

  @SuppressWarnings("unchecked")
  private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
    stream.defaultReadObject();
    int elementCount = stream.readInt();
    if (elementCount < 0) {
      throw new InvalidObjectException("Invalid size: " + elementCount);
    }
    init(elementCount);
    for (int i = 0; i < elementCount; i++) {]]></codefragment>
   </duplication>
   <duplication lines="22" tokens="69">
      <file line="439"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Synchronized.java"/>
      <file line="544"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Synchronized.java"/>
      <file line="737"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Synchronized.java"/>
      <file line="1210"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Synchronized.java"/>
      <codefragment><![CDATA[      }
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      synchronized (mutex) {
        return delegate().equals(o);
      }
    }

    @Override
    public int hashCode() {
      synchronized (mutex) {
        return delegate().hashCode();
      }
    }

    private static final long serialVersionUID = 0;
  }]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="68">
      <file line="452"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="467"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="482"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        return new StrongAccessEntry<>(key, hash, next);
      }

      @Override
      <K, V> ReferenceEntry<K, V> copyEntry(
          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);]]></codefragment>
   </duplication>
   <duplication lines="6" tokens="68">
      <file line="3037"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3083"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3278"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3313"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        int newCount = this.count - 1;
        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
        int index = hash & (table.length() - 1);
        ReferenceEntry<K, V> first = table.get(index);

        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {]]></codefragment>
   </duplication>
   <duplication lines="21" tokens="68">
      <file line="265"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Synchronized.java"/>
      <file line="545"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Synchronized.java"/>
      <file line="738"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Synchronized.java"/>
      <file line="1211"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Synchronized.java"/>
      <codefragment><![CDATA[    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      synchronized (mutex) {
        return delegate().equals(o);
      }
    }

    @Override
    public int hashCode() {
      synchronized (mutex) {
        return delegate().hashCode();
      }
    }

    private static final long serialVersionUID = 0;
  }]]></codefragment>
   </duplication>
   <duplication lines="9" tokens="68">
      <file line="795"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeRangeSet.java"/>
      <file line="828"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeRangeSet.java"/>
      <codefragment><![CDATA[              .min(lowerBoundWindow.upperBound, Cut.belowValue(restriction.upperBound));
      return new AbstractIterator<Entry<Cut<C>, Range<C>>>() {
        @Override
        protected Entry<Cut<C>, Range<C>> computeNext() {
          if (!completeRangeItr.hasNext()) {
            return endOfData();
          }
          Range<C> nextRange = completeRangeItr.next();
          if (upperBoundOnLowerBounds.isLessThan(nextRange.lowerBound)) {]]></codefragment>
   </duplication>
   <duplication lines="29" tokens="68">
      <file line="530"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableDoubleArray.java"/>
      <file line="525"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableIntArray.java"/>
      <file line="527"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableLongArray.java"/>
      <codefragment><![CDATA[        if (!(element instanceof Double) || !areEqual(parent.array[i++], (Double) element)) {
          return false;
        }
      }
      return true;
    }

    // Because we happen to use the same formula. If that changes, just don't override this.
    @Override
    public int hashCode() {
      return parent.hashCode();
    }

    @Override
    public String toString() {
      return parent.toString();
    }
  }

  /**
   * Returns {@code true} if {@code object} is an {@code ImmutableDoubleArray} containing the same
   * values as this one, in the same order. Values are compared as if by {@link Double#equals}.
   */
  @Override
  public boolean equals(@Nullable Object object) {
    if (object == this) {
      return true;
    }
    if (!(object instanceof ImmutableDoubleArray)) {]]></codefragment>
   </duplication>
   <duplication lines="9" tokens="67">
      <file line="3732"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3871"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[      head.setPreviousInWriteQueue(head);
    }

    @Override
    public Iterator<ReferenceEntry<K, V>> iterator() {
      return new AbstractSequentialIterator<ReferenceEntry<K, V>>(peek()) {
        @Override
        protected ReferenceEntry<K, V> computeNext(ReferenceEntry<K, V> previous) {
          ReferenceEntry<K, V> next = previous.getNextInWriteQueue();]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="67">
      <file line="418"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="515"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="784"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="886"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[            K, V, StrongKeyStrongValueEntry<K, V>, StrongKeyStrongValueSegment<K, V>> {
      private static final Helper<?, ?> INSTANCE = new Helper<>();

      @SuppressWarnings("unchecked")
      static <K, V> Helper<K, V> instance() {
        return (Helper<K, V>) INSTANCE;
      }

      @Override
      public Strength keyStrength() {
        return Strength.STRONG;]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="67">
      <file line="332"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Traverser.java"/>
      <file line="355"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Traverser.java"/>
      <file line="378"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Traverser.java"/>
      <codefragment><![CDATA[    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {
      checkNotNull(startNodes);
      if (Iterables.isEmpty(startNodes)) {
        return ImmutableSet.of();
      }
      for (N startNode : startNodes) {
        checkThatNodeIsInGraph(startNode);
      }
      return new Iterable<N>() {
        @Override
        public Iterator<N> iterator() {
          return new BreadthFirstIterator(startNodes);]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="67">
      <file line="498"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Traverser.java"/>
      <file line="544"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Traverser.java"/>
      <codefragment><![CDATA[    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {
      checkNotNull(startNodes);
      if (Iterables.isEmpty(startNodes)) {
        return ImmutableSet.of();
      }
      for (N startNode : startNodes) {
        checkThatNodeIsInTree(startNode);
      }
      return new Iterable<N>() {
        @Override
        public Iterator<N> iterator() {
          return new BreadthFirstIterator(startNodes);]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="67">
      <file line="150"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/HashCode.java"/>
      <file line="216"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/HashCode.java"/>
      <codefragment><![CDATA[    }

    @Override
    void writeBytesToImpl(byte[] dest, int offset, int maxLength) {
      for (int i = 0; i < maxLength; i++) {
        dest[offset + i] = (byte) (hash >> (i * 8));
      }
    }

    @Override
    boolean equalsSameBits(HashCode that) {
      return hash == that.asInt();]]></codefragment>
   </duplication>
   <duplication lines="16" tokens="67">
      <file line="905"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/AbstractFuture.java"/>
      <file line="232"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/Uninterruptibles.java"/>
      <codefragment><![CDATA[  private static <V> V getUninterruptibly(Future<V> future) throws ExecutionException {
    boolean interrupted = false;
    try {
      while (true) {
        try {
          return future.get();
        } catch (InterruptedException e) {
          interrupted = true;
        }
      }
    } finally {
      if (interrupted) {
        Thread.currentThread().interrupt();
      }
    }
  }]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="66">
      <file line="1010"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/CacheBuilder.java"/>
      <file line="297"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMaker.java"/>
      <codefragment><![CDATA[      s.add("expireAfterAccess", expireAfterAccessNanos + "ns");
    }
    if (keyStrength != null) {
      s.add("keyStrength", Ascii.toLowerCase(keyStrength.toString()));
    }
    if (valueStrength != null) {
      s.add("valueStrength", Ascii.toLowerCase(valueStrength.toString()));
    }
    if (keyEquivalence != null) {
      s.addValue("keyEquivalence");
    }]]></codefragment>
   </duplication>
   <duplication lines="19" tokens="66">
      <file line="4125"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2353"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[    segmentFor(hash).refresh(key, hash, defaultLoader, false);
  }

  @Override
  public boolean containsKey(@Nullable Object key) {
    // does not impact recency ordering
    if (key == null) {
      return false;
    }
    int hash = hash(key);
    return segmentFor(hash).containsKey(key, hash);
  }

  @Override
  public boolean containsValue(@Nullable Object value) {
    // does not impact recency ordering
    if (value == null) {
      return false;
    }]]></codefragment>
   </duplication>
   <duplication lines="13" tokens="66">
      <file line="244"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashMap.java"/>
      <file line="244"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashSet.java"/>
      <codefragment><![CDATA[    int hash = smearedHash(key);
    int tableIndex = hash & hashTableMask();
    int newEntryIndex = this.size; // current size, and pointer to the entry to be appended
    int next = table[tableIndex];
    if (next == UNSET) { // uninitialized bucket
      table[tableIndex] = newEntryIndex;
    } else {
      int last;
      long entry;
      do {
        last = next;
        entry = entries[next];
        if (getHash(entry) == hash && Objects.equal(key, keys[next])) {]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="66">
      <file line="370"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableListMultimap.java"/>
      <file line="419"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSetMultimap.java"/>
      <codefragment><![CDATA[    ImmutableMap.Builder<K, ImmutableList<V>> builder =
        new ImmutableMap.Builder<>(mapEntries.size());
    int size = 0;

    for (Entry<? extends K, ? extends Collection<? extends V>> entry : mapEntries) {
      K key = entry.getKey();
      Collection<? extends V> values = entry.getValue();]]></codefragment>
   </duplication>
   <duplication lines="20" tokens="66">
      <file line="268"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <file line="450"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <codefragment><![CDATA[        return new WrappedCollection(key, collection, null);
      }
    }

    // can't use Serialization writeMultimap and populateMultimap methods since
    // there's no way to generate the empty backing map.

    /** @serialData the factory and the backing map */
    @GwtIncompatible // java.io.ObjectOutputStream
    private void writeObject(ObjectOutputStream stream) throws IOException {
      stream.defaultWriteObject();
      stream.writeObject(factory);
      stream.writeObject(backingMap());
    }

    @GwtIncompatible // java.io.ObjectInputStream
    @SuppressWarnings("unchecked") // reading data stored by writeObject
    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
      stream.defaultReadObject();
      factory = (Supplier<? extends Collection<V>>) stream.readObject();]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="66">
      <file line="381"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeRangeSet.java"/>
      <file line="414"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeRangeSet.java"/>
      <codefragment><![CDATA[      }
      return new AbstractIterator<Entry<Cut<C>, Range<C>>>() {
        @Override
        protected Entry<Cut<C>, Range<C>> computeNext() {
          if (!backingItr.hasNext()) {
            return endOfData();
          }
          Range<C> range = backingItr.next();]]></codefragment>
   </duplication>
   <duplication lines="6" tokens="66">
      <file line="47"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/BloomFilterStrategies.java"/>
      <file line="67"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/BloomFilterStrategies.java"/>
      <codefragment><![CDATA[    public <T> boolean put(
        T object, Funnel<? super T> funnel, int numHashFunctions, LockFreeBitArray bits) {
      long bitSize = bits.bitSize();
      long hash64 = Hashing.murmur3_128().hashObject(object, funnel).asLong();
      int hash1 = (int) hash64;
      int hash2 = (int) (hash64 >>> 32);]]></codefragment>
   </duplication>
   <duplication lines="10" tokens="66">
      <file line="287"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableDoubleArray.java"/>
      <file line="284"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableIntArray.java"/>
      <file line="286"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableLongArray.java"/>
      <codefragment><![CDATA[    public Builder addAll(ImmutableDoubleArray values) {
      ensureRoomFor(values.length());
      System.arraycopy(values.array, values.start, array, count, values.length());
      count += values.length();
      return this;
    }

    private void ensureRoomFor(int numberToAdd) {
      int newCount = count + numberToAdd; // TODO(kevinb): check overflow now?
      if (newCount > array.length) {]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="65">
      <file line="452"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="482"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="520"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        return new StrongAccessEntry<>(key, hash, next);
      }

      @Override
      <K, V> ReferenceEntry<K, V> copyEntry(
          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="65">
      <file line="467"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="505"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="535"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        return new StrongWriteEntry<>(key, hash, next);
      }

      @Override
      <K, V> ReferenceEntry<K, V> copyEntry(
          Segment<K, V> segment, ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
        ReferenceEntry<K, V> newEntry = super.copyEntry(segment, original, newNext);]]></codefragment>
   </duplication>
   <duplication lines="6" tokens="65">
      <file line="2782"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2920"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2982"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3136"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3279"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3356"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3390"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
        int index = hash & (table.length() - 1);
        ReferenceEntry<K, V> first = table.get(index);

        // Look for an existing entry.
        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="65">
      <file line="4664"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2777"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[      return v != null && valueEquivalence.equivalent(e.getValue(), v);
    }

    @Override
    public boolean remove(Object o) {
      if (!(o instanceof Entry)) {
        return false;
      }
      Entry<?, ?> e = (Entry<?, ?>) o;
      Object key = e.getKey();
      return key != null && LocalCache.this.remove(key, e.getValue());]]></codefragment>
   </duplication>
   <duplication lines="19" tokens="65">
      <file line="204"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Maps.java"/>
      <file line="239"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Maps.java"/>
      <codefragment><![CDATA[  }

  /**
   * Returns a {@link Collector} that accumulates elements into an {@code ImmutableMap} whose keys
   * and values are the result of applying the provided mapping functions to the input elements. The
   * resulting implementation is specialized for enum key types. The returned map and its views will
   * iterate over keys in their enum definition order, not encounter order.
   *
   * <p>If the mapped keys contain duplicates, an {@code IllegalArgumentException} is thrown when
   * the collection operation is performed. (This differs from the {@code Collector} returned by
   * {@link java.util.stream.Collectors#toMap(java.util.function.Function,
   * java.util.function.Function) Collectors.toMap(Function, Function)}, which throws an {@code
   * IllegalStateException}.)
   *
   * @since 21.0
   */
  public static <T, K extends Enum<K>, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableEnumMap(
      java.util.function.Function<? super T, ? extends K> keyFunction,
      java.util.function.Function<? super T, ? extends V> valueFunction) {]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="65">
      <file line="872"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Ordering.java"/>
      <file line="896"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Ordering.java"/>
      <codefragment><![CDATA[  public boolean isOrdered(Iterable<? extends T> iterable) {
    Iterator<? extends T> it = iterable.iterator();
    if (it.hasNext()) {
      T prev = it.next();
      while (it.hasNext()) {
        T next = it.next();
        if (compare(prev, next) > 0) {]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="65">
      <file line="725"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeMultiset.java"/>
      <file line="742"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeMultiset.java"/>
      <codefragment><![CDATA[        left = initLeft.setCount(comparator, e, count, result);

        if (count == 0 && result[0] != 0) {
          this.distinctElements--;
        } else if (count > 0 && result[0] == 0) {
          this.distinctElements++;
        }

        this.totalCount += count - result[0];
        return rebalance();
      } else if (cmp > 0) {]]></codefragment>
   </duplication>
   <duplication lines="15" tokens="65">
      <file line="163"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/EndpointPair.java"/>
      <file line="211"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/EndpointPair.java"/>
      <codefragment><![CDATA[    }

    @Override
    public boolean equals(@Nullable Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof EndpointPair)) {
        return false;
      }

      EndpointPair<?> other = (EndpointPair<?>) obj;
      if (isOrdered() != other.isOrdered()) {
        return false;
      }]]></codefragment>
   </duplication>
   <duplication lines="20" tokens="65">
      <file line="72"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/ForwardingGraph.java"/>
      <file line="105"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/ForwardingNetwork.java"/>
      <file line="75"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/ForwardingValueGraph.java"/>
      <codefragment><![CDATA[    return delegate().successors(node);
  }

  @Override
  public int degree(N node) {
    return delegate().degree(node);
  }

  @Override
  public int inDegree(N node) {
    return delegate().inDegree(node);
  }

  @Override
  public int outDegree(N node) {
    return delegate().outDegree(node);
  }

  @Override
  public boolean hasEdgeConnecting(N nodeU, N nodeV) {]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="65">
      <file line="465"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Graphs.java"/>
      <file line="492"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Graphs.java"/>
      <codefragment><![CDATA[            : GraphBuilder.from(graph).build();
    for (N node : nodes) {
      subgraph.addNode(node);
    }
    for (N node : subgraph.nodes()) {
      for (N successorNode : graph.successors(node)) {
        if (subgraph.nodes().contains(successorNode)) {
          subgraph.putEdge(node, successorNode);]]></codefragment>
   </duplication>
   <duplication lines="31" tokens="64">
      <file line="695"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableList.java"/>
      <file line="406"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSet.java"/>
      <codefragment><![CDATA[  }

  @Override
  Object writeReplace() {
    return new SerializedForm(toArray());
  }

  /**
   * Returns a new builder. The generated builder is equivalent to the builder created by the {@link
   * Builder} constructor.
   */
  public static <E> Builder<E> builder() {
    return new Builder<E>();
  }

  /**
   * Returns a new builder, expecting the specified number of elements to be added.
   *
   * <p>If {@code expectedSize} is exactly the number of elements added to the builder before {@link
   * Builder#build} is called, the builder is likely to perform better than an unsized {@link
   * #builder()} would have.
   *
   * <p>It is not specified if any performance benefits apply if {@code expectedSize} is close to,
   * but not exactly, the number of elements added to the builder.
   *
   * @since 23.1
   */
  @Beta
  public static <E> Builder<E> builderWithExpectedSize(int expectedSize) {
    checkNonnegative(expectedSize, "expectedSize");
    return new ImmutableList.Builder<E>(expectedSize);]]></codefragment>
   </duplication>
   <duplication lines="10" tokens="64">
      <file line="581"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/LinkedHashMultimap.java"/>
      <file line="831"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/LinkedListMultimap.java"/>
      <codefragment><![CDATA[    stream.writeInt(size());
    for (Entry<K, V> entry : entries()) {
      stream.writeObject(entry.getKey());
      stream.writeObject(entry.getValue());
    }
  }

  @GwtIncompatible // java.io.ObjectInputStream
  private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
    stream.defaultReadObject();]]></codefragment>
   </duplication>
   <duplication lines="18" tokens="64">
      <file line="270"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <file line="352"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <file line="452"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <file line="537"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <codefragment><![CDATA[    }

    // can't use Serialization writeMultimap and populateMultimap methods since
    // there's no way to generate the empty backing map.

    /** @serialData the factory and the backing map */
    @GwtIncompatible // java.io.ObjectOutputStream
    private void writeObject(ObjectOutputStream stream) throws IOException {
      stream.defaultWriteObject();
      stream.writeObject(factory);
      stream.writeObject(backingMap());
    }

    @GwtIncompatible // java.io.ObjectInputStream
    @SuppressWarnings("unchecked") // reading data stored by writeObject
    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
      stream.defaultReadObject();
      factory = (Supplier<? extends Collection<V>>) stream.readObject();]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="63">
      <file line="2195"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2379"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2915"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2977"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[      lock();
      try {
        // re-read ticker once inside the lock
        long now = map.ticker.read();
        preWriteCleanup(now);

        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
        int index = hash & (table.length() - 1);
        ReferenceEntry<K, V> first = table.get(index);

        for (e = first; e != null; e = e.getNext()) {]]></codefragment>
   </duplication>
   <duplication lines="24" tokens="63">
      <file line="4501"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="4585"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[    AbstractCacheSet(ConcurrentMap<?, ?> map) {
      this.map = map;
    }

    @Override
    public int size() {
      return map.size();
    }

    @Override
    public boolean isEmpty() {
      return map.isEmpty();
    }

    @Override
    public void clear() {
      map.clear();
    }

    // super.toArray() may misbehave if size() is inaccurate, at least on old versions of Android.
    // https://code.google.com/p/android/issues/detail?id=36519 / http://r.android.com/47508

    @Override
    public Object[] toArray() {]]></codefragment>
   </duplication>
   <duplication lines="14" tokens="63">
      <file line="4649"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2762"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[      return LocalCache.this.removeIf((k, v) -> filter.test(Maps.immutableEntry(k, v)));
    }

    @Override
    public boolean contains(Object o) {
      if (!(o instanceof Entry)) {
        return false;
      }
      Entry<?, ?> e = (Entry<?, ?>) o;
      Object key = e.getKey();
      if (key == null) {
        return false;
      }
      V v = LocalCache.this.get(key);]]></codefragment>
   </duplication>
   <duplication lines="30" tokens="63">
      <file line="110"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableBiMap.java"/>
      <file line="176"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableMap.java"/>
      <codefragment><![CDATA[        entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3), entryOf(k4, v4), entryOf(k5, v5));
  }

  // looking for of() with > 5 entries? Use the builder instead.

  /**
   * Returns a new builder. The generated builder is equivalent to the builder created by the {@link
   * Builder} constructor.
   */
  public static <K, V> Builder<K, V> builder() {
    return new Builder<>();
  }

  /**
   * Returns a new builder, expecting the specified number of entries to be added.
   *
   * <p>If {@code expectedSize} is exactly the number of entries added to the builder before {@link
   * Builder#build} is called, the builder is likely to perform better than an unsized {@link
   * #builder()} would have.
   *
   * <p>It is not specified if any performance benefits apply if {@code expectedSize} is close to,
   * but not exactly, the number of entries added to the builder.
   *
   * @since 23.1
   */
  @Beta
  public static <K, V> Builder<K, V> builderWithExpectedSize(int expectedSize) {
    checkNonnegative(expectedSize, "expectedSize");
    return new Builder<>(expectedSize);
  }]]></codefragment>
   </duplication>
   <duplication lines="4" tokens="63">
      <file line="62"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableTable.java"/>
      <file line="88"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableTable.java"/>
      <codefragment><![CDATA[  public static <T, R, C, V> Collector<T, ?, ImmutableTable<R, C, V>> toImmutableTable(
      Function<? super T, ? extends R> rowFunction,
      Function<? super T, ? extends C> columnFunction,
      Function<? super T, ? extends V> valueFunction) {]]></codefragment>
   </duplication>
   <duplication lines="6" tokens="63">
      <file line="2777"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Maps.java"/>
      <file line="2791"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Maps.java"/>
      <codefragment><![CDATA[    public boolean removeAll(Collection<?> collection) {
      Iterator<Entry<K, V>> entryItr = unfiltered.entrySet().iterator();
      boolean result = false;
      while (entryItr.hasNext()) {
        Entry<K, V> entry = entryItr.next();
        if (predicate.apply(entry) && collection.contains(entry.getValue())) {]]></codefragment>
   </duplication>
   <duplication lines="16" tokens="63">
      <file line="442"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeMultiset.java"/>
      <file line="484"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeMultiset.java"/>
      <codefragment><![CDATA[        } else if (range.tooHigh(current.getElement())) {
          current = null;
          return false;
        } else {
          return true;
        }
      }

      @Override
      public Entry<E> next() {
        if (!hasNext()) {
          throw new NoSuchElementException();
        }
        Entry<E> result = wrapEntry(current);
        prevEntry = result;
        if (current.succ == header) {]]></codefragment>
   </duplication>
   <duplication lines="1" tokens="63">
      <file line="202"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/IntMath.java"/>
      <file line="207"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/LongMath.java"/>
      <codefragment><![CDATA[    9, 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0,]]></codefragment>
   </duplication>
   <duplication lines="21" tokens="63">
      <file line="335"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/IntMath.java"/>
      <file line="400"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/LongMath.java"/>
      <codefragment><![CDATA[    int signum = 1 | ((p ^ q) >> (Integer.SIZE - 1));
    boolean increment;
    switch (mode) {
      case UNNECESSARY:
        checkRoundingUnnecessary(rem == 0);
        // fall through
      case DOWN:
        increment = false;
        break;
      case UP:
        increment = true;
        break;
      case CEILING:
        increment = signum > 0;
        break;
      case FLOOR:
        increment = signum < 0;
        break;
      case HALF_EVEN:
      case HALF_DOWN:
      case HALF_UP:]]></codefragment>
   </duplication>
   <duplication lines="14" tokens="63">
      <file line="508"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/IntMath.java"/>
      <file line="622"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/LongMath.java"/>
      <codefragment><![CDATA[    int accum = 1;
    while (true) {
      switch (k) {
        case 0:
          return accum;
        case 1:
          return checkedMultiply(accum, b);
        default:
          if ((k & 1) != 0) {
            accum = checkedMultiply(accum, b);
          }
          k >>= 1;
          if (k > 0) {
            checkNoOverflow(-FLOOR_SQRT_MAX_INT <= b & b <= FLOOR_SQRT_MAX_INT, "checkedPow", b, k);]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="62">
      <file line="2389"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2787"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2924"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2986"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3042"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3088"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3140"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        for (e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {
            // We found an existing entry.

            ValueReference<K, V> valueReference = e.getValueReference();]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="62">
      <file line="170"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactLinkedHashMap.java"/>
      <file line="180"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactLinkedHashSet.java"/>
      <codefragment><![CDATA[  }

  @Override
  void moveLastEntry(int dstIndex) {
    int srcIndex = size() - 1;
    super.moveLastEntry(dstIndex);

    setSucceeds(getPredecessor(dstIndex), getSuccessor(dstIndex));
    if (dstIndex < srcIndex) {
      setSucceeds(getPredecessor(srcIndex), dstIndex);
      setSucceeds(dstIndex, getSuccessor(srcIndex));
    }]]></codefragment>
   </duplication>
   <duplication lines="5" tokens="62">
      <file line="150"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/FilteredEntryMultimap.java"/>
      <file line="305"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/FilteredEntryMultimap.java"/>
      <codefragment><![CDATA[    while (entryIterator.hasNext()) {
      Entry<K, Collection<V>> entry = entryIterator.next();
      K key = entry.getKey();
      Collection<V> collection = filterCollection(entry.getValue(), new ValuePredicate(key));
      if (!collection.isEmpty() && predicate.apply(Maps.immutableEntry(key, collection))) {]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="62">
      <file line="364"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableListMultimap.java"/>
      <file line="413"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSetMultimap.java"/>
      <codefragment><![CDATA[  static <K, V> ImmutableListMultimap<K, V> fromMapEntries(
      Collection<? extends Map.Entry<? extends K, ? extends Collection<? extends V>>> mapEntries,
      @Nullable Comparator<? super V> valueComparator) {
    if (mapEntries.isEmpty()) {
      return of();
    }
    ImmutableMap.Builder<K, ImmutableList<V>> builder =]]></codefragment>
   </duplication>
   <duplication lines="36" tokens="62">
      <file line="517"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedMultiset.java"/>
      <file line="512"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedSet.java"/>
      <codefragment><![CDATA[      return this;
    }

    /**
     * Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.
     *
     * @param elements the {@code Iterable} to add to the {@code ImmutableSortedMultiset}
     * @return this {@code Builder} object
     * @throws NullPointerException if {@code elements} is null or contains a null element
     */
    @CanIgnoreReturnValue
    @Override
    public Builder<E> addAll(Iterable<? extends E> elements) {
      super.addAll(elements);
      return this;
    }

    /**
     * Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.
     *
     * @param elements the elements to add to the {@code ImmutableSortedMultiset}
     * @return this {@code Builder} object
     * @throws NullPointerException if {@code elements} is null or contains a null element
     */
    @CanIgnoreReturnValue
    @Override
    public Builder<E> addAll(Iterator<? extends E> elements) {
      super.addAll(elements);
      return this;
    }

    /**
     * Returns a newly-created {@code ImmutableSortedMultiset} based on the contents of the {@code
     * Builder}.
     */
    @Override]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="62">
      <file line="325"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MultimapBuilder.java"/>
      <file line="348"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MultimapBuilder.java"/>
      <codefragment><![CDATA[    public SetMultimapBuilder<K0, Object> hashSetValues(final int expectedValuesPerKey) {
      checkNonnegative(expectedValuesPerKey, "expectedValuesPerKey");
      return new SetMultimapBuilder<K0, Object>() {
        @Override
        public <K extends K0, V> SetMultimap<K, V> build() {
          return Multimaps.newSetMultimap(
              MultimapBuilderWithKeys.this.<K, V>createMap(),
              new HashSetSupplier<V>(expectedValuesPerKey));]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="62">
      <file line="620"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeMultiset.java"/>
      <file line="665"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeMultiset.java"/>
      <file line="716"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeMultiset.java"/>
      <codefragment><![CDATA[    AvlNode<E> add(Comparator<? super E> comparator, @Nullable E e, int count, int[] result) {
      /*
       * It speeds things up considerably to unconditionally add count to totalCount here,
       * but that destroys failure atomicity in the case of count overflow. =(
       */
      int cmp = comparator.compare(e, elem);
      if (cmp < 0) {
        AvlNode<E> initLeft = left;
        if (initLeft == null) {
          result[0] = 0;
          return addLeftChild(e, count);]]></codefragment>
   </duplication>
   <duplication lines="6" tokens="62">
      <file line="73"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/eventbus/SubscriberRegistry.java"/>
      <file line="93"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/eventbus/SubscriberRegistry.java"/>
      <codefragment><![CDATA[  void register(Object listener) {
    Multimap<Class<?>, Subscriber> listenerMethods = findAllSubscribers(listener);

    for (Entry<Class<?>, Collection<Subscriber>> entry : listenerMethods.asMap().entrySet()) {
      Class<?> eventType = entry.getKey();
      Collection<Subscriber> eventMethodsInListener = entry.getValue();]]></codefragment>
   </duplication>
   <duplication lines="6" tokens="62">
      <file line="95"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/BloomFilterStrategies.java"/>
      <file line="113"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/BloomFilterStrategies.java"/>
      <codefragment><![CDATA[    public <T> boolean put(
        T object, Funnel<? super T> funnel, int numHashFunctions, LockFreeBitArray bits) {
      long bitSize = bits.bitSize();
      byte[] bytes = Hashing.murmur3_128().hashObject(object, funnel).getBytesInternal();
      long hash1 = lowerEight(bytes);
      long hash2 = upperEight(bytes);]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="62">
      <file line="703"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/io/BaseEncoding.java"/>
      <file line="942"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/io/BaseEncoding.java"/>
      <codefragment><![CDATA[    }

    @Override
    int decodeTo(byte[] target, CharSequence chars) throws DecodingException {
      checkNotNull(target);
      chars = trimTrailingPadding(chars);
      if (!alphabet.isValidPaddingStartPosition(chars.length())) {
        throw new DecodingException("Invalid input length " + chars.length());
      }
      int bytesWritten = 0;
      for (int charIdx = 0; charIdx < chars.length(); charIdx += alphabet.charsPerChunk) {]]></codefragment>
   </duplication>
   <duplication lines="18" tokens="61">
      <file line="278"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="173"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[    while (segmentCount < concurrencyLevel && (!evictsBySize() || segmentCount * 20 <= maxWeight)) {
      ++segmentShift;
      segmentCount <<= 1;
    }
    this.segmentShift = 32 - segmentShift;
    segmentMask = segmentCount - 1;

    this.segments = newSegmentArray(segmentCount);

    int segmentCapacity = initialCapacity / segmentCount;
    if (segmentCapacity * segmentCount < initialCapacity) {
      ++segmentCapacity;
    }

    int segmentSize = 1;
    while (segmentSize < segmentCapacity) {
      segmentSize <<= 1;
    }]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="61">
      <file line="4250"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2449"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[  @Override
  public boolean replace(K key, @Nullable V oldValue, V newValue) {
    checkNotNull(key);
    checkNotNull(newValue);
    if (oldValue == null) {
      return false;
    }
    int hash = hash(key);
    return segmentFor(hash).replace(key, hash, oldValue, newValue);
  }

  @Override]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="61">
      <file line="1251"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/AbstractMapBasedMultimap.java"/>
      <file line="588"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableMultimap.java"/>
      <codefragment><![CDATA[        map.entrySet().spliterator(),
        keyToValueCollectionEntry -> {
          K key = keyToValueCollectionEntry.getKey();
          Collection<V> valueCollection = keyToValueCollectionEntry.getValue();
          return CollectSpliterators.map(
              valueCollection.spliterator(), (V value) -> Maps.immutableEntry(key, value));
        },
        Spliterator.SIZED,]]></codefragment>
   </duplication>
   <duplication lines="6" tokens="61">
      <file line="129"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/AbstractTable.java"/>
      <file line="141"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/AbstractTable.java"/>
      <codefragment><![CDATA[    public boolean contains(Object o) {
      if (o instanceof Cell) {
        Cell<?, ?, ?> cell = (Cell<?, ?, ?>) o;
        Map<C, V> row = Maps.safeGet(rowMap(), cell.getRowKey());
        return row != null
            && Collections2.safeContains(]]></codefragment>
   </duplication>
   <duplication lines="18" tokens="61">
      <file line="137"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactLinkedHashMap.java"/>
      <file line="159"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactLinkedHashSet.java"/>
      <codefragment><![CDATA[  }

  private void setSucceeds(int pred, int succ) {
    if (pred == ENDPOINT) {
      firstEntry = succ;
    } else {
      setSuccessor(pred, succ);
    }

    if (succ == ENDPOINT) {
      lastEntry = pred;
    } else {
      setPredecessor(succ, pred);
    }
  }

  @Override
  void insertEntry(int entryIndex, K key, V value, int hash) {]]></codefragment>
   </duplication>
   <duplication lines="18" tokens="61">
      <file line="70"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/HashMultiset.java"/>
      <file line="78"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/LinkedHashMultiset.java"/>
      <codefragment><![CDATA[    super(Maps.<E, Count>newHashMapWithExpectedSize(distinctElements));
  }

  /**
   * @serialData the number of distinct elements, the first element, its count, the second element,
   *     its count, and so on
   */
  @GwtIncompatible // java.io.ObjectOutputStream
  private void writeObject(ObjectOutputStream stream) throws IOException {
    stream.defaultWriteObject();
    Serialization.writeMultiset(this, stream);
  }

  @GwtIncompatible // java.io.ObjectInputStream
  private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
    stream.defaultReadObject();
    int distinctElements = Serialization.readCount(stream);
    setBackingMap(Maps.<E, Count>newHashMap());]]></codefragment>
   </duplication>
   <duplication lines="15" tokens="61">
      <file line="475"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Streams.java"/>
      <file line="554"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Streams.java"/>
      <file line="634"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Streams.java"/>
      <codefragment><![CDATA[      public void accept(int t) {
        this.holder = t;
      }

      @Override
      public boolean tryAdvance(Consumer<? super R> action) {
        if (fromSpliterator.tryAdvance(this)) {
          action.accept(function.apply(holder, index++));
          return true;
        }
        return false;
      }

      @Override
      Splitr createSplit(Spliterator.OfInt from, long i) {]]></codefragment>
   </duplication>
   <duplication lines="10" tokens="61">
      <file line="227"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/IntMath.java"/>
      <file line="490"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/IntMath.java"/>
      <file line="568"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/IntMath.java"/>
      <codefragment><![CDATA[  public static int pow(int b, int k) {
    checkNonNegative("exponent", k);
    switch (b) {
      case 0:
        return (k == 0) ? 1 : 0;
      case 1:
        return 1;
      case (-1):
        return ((k & 1) == 0) ? 1 : -1;
      case 2:]]></codefragment>
   </duplication>
   <duplication lines="16" tokens="61">
      <file line="261"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Booleans.java"/>
      <file line="341"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Chars.java"/>
      <file line="330"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Doubles.java"/>
      <file line="325"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Floats.java"/>
      <file line="389"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Ints.java"/>
      <file line="485"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Longs.java"/>
      <file line="388"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Shorts.java"/>
      <codefragment><![CDATA[  public static boolean[] ensureCapacity(boolean[] array, int minLength, int padding) {
    checkArgument(minLength >= 0, "Invalid minLength: %s", minLength);
    checkArgument(padding >= 0, "Invalid padding: %s", padding);
    return (array.length < minLength) ? Arrays.copyOf(array, minLength + padding) : array;
  }

  /**
   * Returns a string containing the supplied {@code boolean} values separated by {@code separator}.
   * For example, {@code join("-", false, true, false)} returns the string {@code
   * "false-true-false"}.
   *
   * @param separator the text that should appear between consecutive values in the resulting string
   *     (but not at the start or end)
   * @param array an array of {@code boolean} values, possibly empty
   */
  public static String join(String separator, boolean... array) {]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="60">
      <file line="165"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ForwardingSortedMultiset.java"/>
      <file line="188"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ForwardingSortedMultiset.java"/>
      <codefragment><![CDATA[    Iterator<Entry<E>> entryIterator = entrySet().iterator();
    if (!entryIterator.hasNext()) {
      return null;
    }
    Entry<E> entry = entryIterator.next();
    entry = Multisets.immutableEntry(entry.getElement(), entry.getCount());
    entryIterator.remove();
    return entry;
  }

  @Override
  public Entry<E> pollLastEntry() {]]></codefragment>
   </duplication>
   <duplication lines="9" tokens="60">
      <file line="478"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableListMultimap.java"/>
      <file line="613"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSetMultimap.java"/>
      <codefragment><![CDATA[    ImmutableMap.Builder<Object, ImmutableList<Object>> builder = ImmutableMap.builder();
    int tmpSize = 0;

    for (int i = 0; i < keyCount; i++) {
      Object key = stream.readObject();
      int valueCount = stream.readInt();
      if (valueCount <= 0) {
        throw new InvalidObjectException("Invalid value count " + valueCount);
      }]]></codefragment>
   </duplication>
   <duplication lines="9" tokens="60">
      <file line="496"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableListMultimap.java"/>
      <file line="635"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSetMultimap.java"/>
      <codefragment><![CDATA[    ImmutableMap<Object, ImmutableList<Object>> tmpMap;
    try {
      tmpMap = builder.build();
    } catch (IllegalArgumentException e) {
      throw (InvalidObjectException) new InvalidObjectException(e.getMessage()).initCause(e);
    }

    FieldSettersHolder.MAP_FIELD_SETTER.set(this, tmpMap);
    FieldSettersHolder.SIZE_FIELD_SETTER.set(this, tmpSize);]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="60">
      <file line="1690"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1730"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1911"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[        preWriteCleanup();

        int newCount = this.count - 1;
        AtomicReferenceArray<E> table = this.table;
        int index = hash & (table.length() - 1);
        E first = table.get(index);

        for (E e = first; e != null; e = e.getNext()) {]]></codefragment>
   </duplication>
   <duplication lines="9" tokens="60">
      <file line="670"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/StandardTable.java"/>
      <file line="689"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/StandardTable.java"/>
      <codefragment><![CDATA[    public boolean removeAll(Collection<?> c) {
      checkNotNull(c);
      boolean changed = false;
      Iterator<Map<C, V>> iterator = backingMap.values().iterator();
      while (iterator.hasNext()) {
        Map<C, V> map = iterator.next();
        // map.keySet().removeAll(c) can throw a NPE when map is a TreeMap with
        // natural ordering and c contains a null.
        if (Iterators.removeAll(map.keySet().iterator(), c)) {]]></codefragment>
   </duplication>
   <duplication lines="17" tokens="59">
      <file line="1175"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1239"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <codefragment><![CDATA[      T obj, @Nullable String errorMessageTemplate, long p1, @Nullable Object p2) {
    if (obj == null) {
      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
    }
    return obj;
  }

  /**
   * Ensures that an object reference passed as a parameter to the calling method is not null.
   *
   * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
   *
   * @since 20.0 (varargs overload since 2.0)
   */
  @CanIgnoreReturnValue
  public static <T extends @NonNull Object> T checkNotNull(
      T obj, @Nullable String errorMessageTemplate, @Nullable Object p1, char p2) {]]></codefragment>
   </duplication>
   <duplication lines="13" tokens="59">
      <file line="45"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/AbstractLoadingCache.java"/>
      <file line="4961"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[  protected AbstractLoadingCache() {}

  @Override
  public V getUnchecked(K key) {
    try {
      return get(key);
    } catch (ExecutionException e) {
      throw new UncheckedExecutionException(e.getCause());
    }
  }

  @Override
  public ImmutableMap<K, V> getAll(Iterable<? extends K> keys) throws ExecutionException {]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="59">
      <file line="4222"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2418"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[        key, (k, oldValue) -> (oldValue == null) ? newValue : function.apply(oldValue, newValue));
  }

  @Override
  public void putAll(Map<? extends K, ? extends V> m) {
    for (Entry<? extends K, ? extends V> e : m.entrySet()) {
      put(e.getKey(), e.getValue());
    }
  }

  @Override]]></codefragment>
   </duplication>
   <duplication lines="5" tokens="59">
      <file line="62"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/DenseImmutableTable.java"/>
      <file line="57"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/SparseImmutableTable.java"/>
      <codefragment><![CDATA[    int[] cellColumnIndices = new int[cellList.size()];
    for (int i = 0; i < cellList.size(); i++) {
      Cell<R, C, V> cell = cellList.get(i);
      R rowKey = cell.getRowKey();
      C columnKey = cell.getColumnKey();]]></codefragment>
   </duplication>
   <duplication lines="6" tokens="59">
      <file line="286"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableMultimap.java"/>
      <file line="353"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSetMultimap.java"/>
      <codefragment><![CDATA[    public ImmutableMultimap<K, V> build() {
      Collection<Map.Entry<K, Collection<V>>> mapEntries = builderMap.entrySet();
      if (keyComparator != null) {
        mapEntries = Ordering.from(keyComparator).<K>onKeys().immutableSortedCopy(mapEntries);
      }
      return ImmutableListMultimap.fromMapEntries(mapEntries, valueComparator);]]></codefragment>
   </duplication>
   <duplication lines="40" tokens="59">
      <file line="287"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <file line="366"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <file line="466"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <codefragment><![CDATA[      factory = (Supplier<? extends Collection<V>>) stream.readObject();
      Map<K, Collection<V>> map = (Map<K, Collection<V>>) stream.readObject();
      setMap(map);
    }

    @GwtIncompatible // java serialization not supported
    private static final long serialVersionUID = 0;
  }

  /**
   * Creates a new {@code ListMultimap} that uses the provided map and factory. It can generate a
   * multimap based on arbitrary {@link Map} and {@link List} classes.
   *
   * <p>The {@code factory}-generated and {@code map} classes determine the multimap iteration
   * order. They also specify the behavior of the {@code equals}, {@code hashCode}, and {@code
   * toString} methods for the multimap and its returned views. The multimap's {@code get}, {@code
   * removeAll}, and {@code replaceValues} methods return {@code RandomAccess} lists if the factory
   * does. However, the multimap's {@code get} method returns instances of a different class than
   * does {@code factory.get()}.
   *
   * <p>The multimap is serializable if {@code map}, {@code factory}, the lists generated by {@code
   * factory}, and the multimap contents are all serializable.
   *
   * <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if
   * {@code map} and the instances generated by {@code factory} are. Concurrent read operations will
   * work correctly. To allow concurrent update operations, wrap the multimap with a call to {@link
   * #synchronizedListMultimap}.
   *
   * <p>Call this method only when the simpler methods {@link ArrayListMultimap#create()} and {@link
   * LinkedListMultimap#create()} won't suffice.
   *
   * <p>Note: the multimap assumes complete ownership over of {@code map} and the lists returned by
   * {@code factory}. Those objects should not be manually updated, they should be empty when
   * provided, and they should not use soft, weak, or phantom references.
   *
   * @param map place to store the mapping from each key to its corresponding values
   * @param factory supplier of new, empty lists that will each hold all values for a given key
   * @throws IllegalArgumentException if {@code map} is not empty
   */
  public static <K, V> ListMultimap<K, V> newListMultimap(]]></codefragment>
   </duplication>
   <duplication lines="20" tokens="59">
      <file line="602"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Synchronized.java"/>
      <file line="1044"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Synchronized.java"/>
      <codefragment><![CDATA[        return delegate().isEmpty();
      }
    }

    @Override
    public boolean containsKey(Object key) {
      synchronized (mutex) {
        return delegate().containsKey(key);
      }
    }

    @Override
    public boolean containsValue(Object value) {
      synchronized (mutex) {
        return delegate().containsValue(value);
      }
    }

    @Override
    public boolean containsEntry(Object key, Object value) {]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="59">
      <file line="98"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/escape/ArrayBasedCharEscaper.java"/>
      <file line="136"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/escape/ArrayBasedUnicodeEscaper.java"/>
      <codefragment><![CDATA[  }

  /*
   * This is overridden to improve performance. Rough benchmarking shows that this almost doubles
   * the speed when processing strings that do not require any escaping.
   */
  @Override
  public final String escape(String s) {
    checkNotNull(s); // GWT specific check (do not optimize).
    for (int i = 0; i < s.length(); i++) {
      char c = s.charAt(i);
      if ((c < replacementsLength && replacements[c] != null) || c > safeMax || c < safeMin) {]]></codefragment>
   </duplication>
   <duplication lines="15" tokens="59">
      <file line="547"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/io/Files.java"/>
      <file line="148"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/io/Resources.java"/>
      <codefragment><![CDATA[            new LineProcessor<List<String>>() {
              final List<String> result = Lists.newArrayList();

              @Override
              public boolean processLine(String line) {
                result.add(line);
                return true;
              }

              @Override
              public List<String> getResult() {
                return result;
              }
            });
  }]]></codefragment>
   </duplication>
   <duplication lines="17" tokens="59">
      <file line="260"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/PairedStats.java"/>
      <file line="230"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/PairedStatsAccumulator.java"/>
      <codefragment><![CDATA[  private static double ensurePositive(double value) {
    if (value > 0.0) {
      return value;
    } else {
      return Double.MIN_VALUE;
    }
  }

  private static double ensureInUnitRange(double value) {
    if (value >= 1.0) {
      return 1.0;
    }
    if (value <= -1.0) {
      return -1.0;
    }
    return value;
  }]]></codefragment>
   </duplication>
   <duplication lines="22" tokens="59">
      <file line="452"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Ints.java"/>
      <file line="239"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/UnsignedInts.java"/>
      <codefragment><![CDATA[    }
  }

  /**
   * Sorts the elements of {@code array} in descending order.
   *
   * @since 23.1
   */
  public static void sortDescending(int[] array) {
    checkNotNull(array);
    sortDescending(array, 0, array.length);
  }

  /**
   * Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
   * exclusive in descending order.
   *
   * @since 23.1
   */
  public static void sortDescending(int[] array, int fromIndex, int toIndex) {
    checkNotNull(array);
    checkPositionIndexes(fromIndex, toIndex, array.length);]]></codefragment>
   </duplication>
   <duplication lines="22" tokens="59">
      <file line="549"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Longs.java"/>
      <file line="205"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/UnsignedLongs.java"/>
      <codefragment><![CDATA[    }
  }

  /**
   * Sorts the elements of {@code array} in descending order.
   *
   * @since 23.1
   */
  public static void sortDescending(long[] array) {
    checkNotNull(array);
    sortDescending(array, 0, array.length);
  }

  /**
   * Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
   * exclusive in descending order.
   *
   * @since 23.1
   */
  public static void sortDescending(long[] array, int fromIndex, int toIndex) {
    checkNotNull(array);
    checkPositionIndexes(fromIndex, toIndex, array.length);]]></codefragment>
   </duplication>
   <duplication lines="22" tokens="59">
      <file line="194"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/SignedBytes.java"/>
      <file line="479"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/UnsignedBytes.java"/>
      <codefragment><![CDATA[    }
  }

  /**
   * Sorts the elements of {@code array} in descending order.
   *
   * @since 23.1
   */
  public static void sortDescending(byte[] array) {
    checkNotNull(array);
    sortDescending(array, 0, array.length);
  }

  /**
   * Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
   * exclusive in descending order.
   *
   * @since 23.1
   */
  public static void sortDescending(byte[] array, int fromIndex, int toIndex) {
    checkNotNull(array);
    checkPositionIndexes(fromIndex, toIndex, array.length);]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="58">
      <file line="4261"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2461"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[  @Override
  public V replace(K key, V value) {
    checkNotNull(key);
    checkNotNull(value);
    int hash = hash(key);
    return segmentFor(hash).replace(key, hash, value);
  }

  @Override
  public void clear() {
    for (Segment<K, V> segment : segments) {]]></codefragment>
   </duplication>
   <duplication lines="13" tokens="58">
      <file line="226"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Collections2.java"/>
      <file line="2802"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Maps.java"/>
      <file line="2948"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Maps.java"/>
      <codefragment><![CDATA[    }

    @Override
    public Object[] toArray() {
      // creating an ArrayList so filtering happens once
      return Lists.newArrayList(iterator()).toArray();
    }

    @Override
    public <T> T[] toArray(T[] array) {
      return Lists.newArrayList(iterator()).toArray(array);
    }
  }]]></codefragment>
   </duplication>
   <duplication lines="13" tokens="58">
      <file line="125"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ForwardingMap.java"/>
      <file line="82"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ForwardingMultiset.java"/>
      <codefragment><![CDATA[  public Set<Entry<K, V>> entrySet() {
    return delegate().entrySet();
  }

  @Override
  public boolean equals(@Nullable Object object) {
    return object == this || delegate().equals(object);
  }

  @Override
  public int hashCode() {
    return delegate().hashCode();
  }]]></codefragment>
   </duplication>
   <duplication lines="6" tokens="58">
      <file line="1847"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1912"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[        int newCount = this.count - 1;
        AtomicReferenceArray<E> table = this.table;
        int index = hash & (table.length() - 1);
        E first = table.get(index);

        for (E e = first; e != null; e = e.getNext()) {]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="58">
      <file line="230"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Maps.java"/>
      <file line="261"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Maps.java"/>
      <codefragment><![CDATA[                }),
        (accum, t) -> {
          K key = checkNotNull(keyFunction.apply(t), "Null key for input %s", t);
          V newValue = checkNotNull(valueFunction.apply(t), "Null value for input %s", t);
          accum.put(key, newValue);
        },
        Accumulator::combine,
        Accumulator::toImmutableMap,]]></codefragment>
   </duplication>
   <duplication lines="17" tokens="58">
      <file line="222"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <file line="334"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <file line="412"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <codefragment><![CDATA[    CustomMultimap(Map<K, Collection<V>> map, Supplier<? extends Collection<V>> factory) {
      super(map);
      this.factory = checkNotNull(factory);
    }

    @Override
    Set<K> createKeySet() {
      return createMaybeNavigableKeySet();
    }

    @Override
    Map<K, Collection<V>> createAsMap() {
      return createMaybeNavigableAsMap();
    }

    @Override
    protected Collection<V> createCollection() {]]></codefragment>
   </duplication>
   <duplication lines="6" tokens="58">
      <file line="537"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Graphs.java"/>
      <file line="550"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Graphs.java"/>
      <codefragment><![CDATA[    MutableGraph<N> copy = GraphBuilder.from(graph).expectedNodeCount(graph.nodes().size()).build();
    for (N node : graph.nodes()) {
      copy.addNode(node);
    }
    for (EndpointPair<N> edge : graph.edges()) {
      copy.putEdge(edge.nodeU(), edge.nodeV());]]></codefragment>
   </duplication>
   <duplication lines="10" tokens="57">
      <file line="266"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableList.java"/>
      <file line="266"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSet.java"/>
      <codefragment><![CDATA[  public static <E> ImmutableList<E> copyOf(Iterator<? extends E> elements) {
    // We special-case for 0 or 1 elements, but going further is madness.
    if (!elements.hasNext()) {
      return of();
    }
    E first = elements.next();
    if (!elements.hasNext()) {
      return of(first);
    } else {
      return new ImmutableList.Builder<E>().add(first).addAll(elements).build();]]></codefragment>
   </duplication>
   <duplication lines="13" tokens="57">
      <file line="358"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableRangeMap.java"/>
      <file line="509"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeRangeMap.java"/>
      <file line="687"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeRangeMap.java"/>
      <codefragment><![CDATA[  }

  @Override
  public boolean equals(@Nullable Object o) {
    if (o instanceof RangeMap) {
      RangeMap<?, ?> rangeMap = (RangeMap<?, ?>) o;
      return asMapOfRanges().equals(rangeMap.asMapOfRanges());
    }
    return false;
  }

  @Override
  public String toString() {]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="57">
      <file line="566"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableRangeSet.java"/>
      <file line="587"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableRangeSet.java"/>
      <codefragment><![CDATA[        final Iterator<Range<C>> rangeItr = ranges.iterator();
        Iterator<C> elemItr = Iterators.emptyIterator();

        @Override
        protected C computeNext() {
          while (!elemItr.hasNext()) {
            if (rangeItr.hasNext()) {
              elemItr = ContiguousSet.create(rangeItr.next(), domain).iterator();]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="57">
      <file line="595"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="700"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[            K, Dummy, StrongKeyDummyValueEntry<K>, StrongKeyDummyValueSegment<K>> {
      private static final Helper<?> INSTANCE = new Helper<>();

      @SuppressWarnings("unchecked")
      static <K> Helper<K> instance() {
        return (Helper<K>) INSTANCE;
      }

      @Override
      public Strength keyStrength() {
        return Strength.STRONG;]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="57">
      <file line="3488"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Maps.java"/>
      <file line="4132"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Maps.java"/>
      <codefragment><![CDATA[    private transient @MonotonicNonNull Set<Entry<K, V>> entrySet;

    @Override
    public Set<Entry<K, V>> entrySet() {
      Set<Entry<K, V>> result = entrySet;
      return (result == null) ? entrySet = createEntrySet() : result;
    }]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="57">
      <file line="151"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/RegularImmutableBiMap.java"/>
      <file line="179"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/RegularImmutableMap.java"/>
      <codefragment><![CDATA[  }

  @Override
  public void forEach(BiConsumer<? super K, ? super V> action) {
    checkNotNull(action);
    for (Entry<K, V> entry : entries) {
      action.accept(entry.getKey(), entry.getValue());
    }
  }

  @Override]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="57">
      <file line="353"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Bytes.java"/>
      <file line="624"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Chars.java"/>
      <file line="634"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Doubles.java"/>
      <file line="620"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Floats.java"/>
      <file line="678"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Ints.java"/>
      <file line="775"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Longs.java"/>
      <file line="671"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Shorts.java"/>
      <codefragment><![CDATA[      StringBuilder builder = new StringBuilder(size() * 5);
      builder.append('[').append(array[start]);
      for (int i = start + 1; i < end; i++) {
        builder.append(", ").append(array[i]);
      }
      return builder.append(']').toString();
    }]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="57">
      <file line="176"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/SignedBytes.java"/>
      <file line="411"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/UnsignedBytes.java"/>
      <codefragment><![CDATA[  private enum LexicographicalComparator implements Comparator<byte[]> {
    INSTANCE;

    @Override
    public int compare(byte[] left, byte[] right) {
      int minLength = Math.min(left.length, right.length);
      for (int i = 0; i < minLength; i++) {
        int result = SignedBytes.compare(left[i], right[i]);]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="57">
      <file line="172"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/AtomicDoubleArray.java"/>
      <file line="192"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/AtomicDoubleArray.java"/>
      <codefragment><![CDATA[  public final double getAndAdd(int i, double delta) {
    while (true) {
      long current = longs.get(i);
      double currentVal = longBitsToDouble(current);
      double nextVal = currentVal + delta;
      long next = doubleToRawLongBits(nextVal);
      if (longs.compareAndSet(i, current, next)) {
        return currentVal;]]></codefragment>
   </duplication>
   <duplication lines="13" tokens="56">
      <file line="119"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Suppliers.java"/>
      <file line="157"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Suppliers.java"/>
      <codefragment><![CDATA[    MemoizingSupplier(Supplier<T> delegate) {
      this.delegate = checkNotNull(delegate);
    }

    @Override
    public T get() {
      // A 2-field variant of Double Checked Locking.
      if (!initialized) {
        synchronized (this) {
          if (!initialized) {
            T t = delegate.get();
            value = t;
            initialized = true;]]></codefragment>
   </duplication>
   <duplication lines="14" tokens="56">
      <file line="3678"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3817"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[      ReferenceEntry<K, V> next = head.getNextInWriteQueue();
      if (next == head) {
        return null;
      }

      remove(next);
      return next;
    }

    @Override
    @SuppressWarnings("unchecked")
    public boolean remove(Object o) {
      ReferenceEntry<K, V> e = (ReferenceEntry) o;
      ReferenceEntry<K, V> previous = e.getPreviousInWriteQueue();]]></codefragment>
   </duplication>
   <duplication lines="4" tokens="56">
      <file line="77"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CollectCollectors.java"/>
      <file line="75"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedMap.java"/>
      <codefragment><![CDATA[  static <T, K, V> Collector<T, ?, ImmutableSortedMap<K, V>> toImmutableSortedMap(
      Comparator<? super K> comparator,
      Function<? super T, ? extends K> keyFunction,
      Function<? super T, ? extends V> valueFunction) {]]></codefragment>
   </duplication>
   <duplication lines="4" tokens="56">
      <file line="122"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CollectCollectors.java"/>
      <file line="56"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableRangeMap.java"/>
      <codefragment><![CDATA[  static <T, K extends Comparable<? super K>, V>
      Collector<T, ?, ImmutableRangeMap<K, V>> toImmutableRangeMap(
          Function<? super T, Range<K>> keyFunction,
          Function<? super T, ? extends V> valueFunction) {]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="56">
      <file line="264"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashMap.java"/>
      <file line="258"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashSet.java"/>
      <codefragment><![CDATA[        }
        next = getNext(entry);
      } while (next != UNSET);
      entries[last] = swapNext(entry, newEntryIndex);
    }
    if (newEntryIndex == Integer.MAX_VALUE) {
      throw new IllegalStateException("Cannot contain more than Integer.MAX_VALUE elements!");
    }
    int newSize = newEntryIndex + 1;
    resizeMeMaybe(newSize);
    insertEntry(newEntryIndex, key, value, hash);]]></codefragment>
   </duplication>
   <duplication lines="10" tokens="56">
      <file line="124"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ForwardingSortedMultiset.java"/>
      <file line="145"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ForwardingSortedMultiset.java"/>
      <codefragment><![CDATA[    Iterator<Entry<E>> entryIterator = entrySet().iterator();
    if (!entryIterator.hasNext()) {
      return null;
    }
    Entry<E> entry = entryIterator.next();
    return Multisets.immutableEntry(entry.getElement(), entry.getCount());
  }

  @Override
  public Entry<E> lastEntry() {]]></codefragment>
   </duplication>
   <duplication lines="47" tokens="56">
      <file line="1281"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <file line="1328"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <codefragment><![CDATA[      Multimap<K, V1> fromMultimap, final Function<? super V1, V2> function) {
    checkNotNull(function);
    EntryTransformer<K, V1, V2> transformer = Maps.asEntryTransformer(function);
    return transformEntries(fromMultimap, transformer);
  }

  /**
   * Returns a view of a {@code ListMultimap} where each value is transformed by a function. All
   * other properties of the multimap, such as iteration order, are left intact. For example, the
   * code:
   *
   * <pre>{@code
   * ListMultimap<String, Integer> multimap
   *      = ImmutableListMultimap.of("a", 4, "a", 16, "b", 9);
   * Function<Integer, Double> sqrt =
   *     new Function<Integer, Double>() {
   *       public Double apply(Integer in) {
   *         return Math.sqrt((int) in);
   *       }
   *     };
   * ListMultimap<String, Double> transformed = Multimaps.transformValues(map,
   *     sqrt);
   * System.out.println(transformed);
   * }</pre>
   *
   * ... prints {@code {a=[2.0, 4.0], b=[3.0]}}.
   *
   * <p>Changes in the underlying multimap are reflected in this view. Conversely, this view
   * supports removal operations, and these are reflected in the underlying multimap.
   *
   * <p>It's acceptable for the underlying multimap to contain null keys, and even null values
   * provided that the function is capable of accepting null input. The transformed multimap might
   * contain null values, if the function sometimes gives a null result.
   *
   * <p>The returned multimap is not thread-safe or serializable, even if the underlying multimap
   * is.
   *
   * <p>The function is applied lazily, invoked when needed. This is necessary for the returned
   * multimap to be a view, but it means that the function will be applied many times for bulk
   * operations like {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to
   * perform well, {@code function} should be fast. To avoid lazy evaluation when the returned
   * multimap doesn't need to be a view, copy the returned multimap into a new multimap of your
   * choosing.
   *
   * @since 7.0
   */
  public static <K, V1, V2> ListMultimap<K, V2> transformValues(]]></codefragment>
   </duplication>
   <duplication lines="20" tokens="56">
      <file line="568"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/LongMath.java"/>
      <file line="686"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/LongMath.java"/>
      <codefragment><![CDATA[  public static long checkedMultiply(long a, long b) {
    // Hacker's Delight, Section 2-12
    int leadingZeros =
        Long.numberOfLeadingZeros(a)
            + Long.numberOfLeadingZeros(~a)
            + Long.numberOfLeadingZeros(b)
            + Long.numberOfLeadingZeros(~b);
    /*
     * If leadingZeros > Long.SIZE + 1 it's definitely fine, if it's < Long.SIZE it's definitely
     * bad. We do the leadingZeros check to avoid the division below if at all possible.
     *
     * Otherwise, if b == Long.MIN_VALUE, then the only allowed values of a are 0 and 1. We take
     * care of all a < 0 with their own check, because in particular, the case a == -1 will
     * incorrectly pass the division check below.
     *
     * In all other cases, we check that either a is 0 or the result is consistent with division.
     */
    if (leadingZeros > Long.SIZE + 1) {
      return a * b;
    }]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="56">
      <file line="434"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Ints.java"/>
      <file line="194"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/UnsignedInts.java"/>
      <codefragment><![CDATA[  private enum LexicographicalComparator implements Comparator<int[]> {
    INSTANCE;

    @Override
    public int compare(int[] left, int[] right) {
      int minLength = Math.min(left.length, right.length);
      for (int i = 0; i < minLength; i++) {]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="56">
      <file line="531"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Longs.java"/>
      <file line="160"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/UnsignedLongs.java"/>
      <codefragment><![CDATA[  private enum LexicographicalComparator implements Comparator<long[]> {
    INSTANCE;

    @Override
    public int compare(long[] left, long[] right) {
      int minLength = Math.min(left.length, right.length);
      for (int i = 0; i < minLength; i++) {]]></codefragment>
   </duplication>
   <duplication lines="26" tokens="56">
      <file line="935"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/MoreExecutors.java"/>
      <file line="969"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/MoreExecutors.java"/>
      <codefragment><![CDATA[    return new WrappingExecutorService(service) {
      @Override
      protected <T> Callable<T> wrapTask(Callable<T> callable) {
        return Callables.threadRenaming(callable, nameSupplier);
      }

      @Override
      protected Runnable wrapTask(Runnable command) {
        return Callables.threadRenaming(command, nameSupplier);
      }
    };
  }

  /**
   * Creates a {@link ScheduledExecutorService} that renames the {@link Thread threads} that its
   * tasks run in.
   *
   * <p>The names are retrieved from the {@code nameSupplier} on the thread that is being renamed
   * right before each task is run. The renaming is best effort, if a {@link SecurityManager}
   * prevents the renaming then it will be skipped but the tasks will still execute.
   *
   *
   * @param service The executor to decorate
   * @param nameSupplier The source of names for each task
   */
  @GwtIncompatible // concurrency]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="55">
      <file line="2389"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3318"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3360"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        for (e = first; e != null; e = e.getNext()) {
          K entryKey = e.getKey();
          if (e.getHash() == hash
              && entryKey != null
              && map.keyEquivalence.equivalent(key, entryKey)) {
            // We found an existing entry.

            ValueReference<K, V> valueReference = e.getValueReference();]]></codefragment>
   </duplication>
   <duplication lines="4" tokens="55">
      <file line="57"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableBiMapFauxverideShim.java"/>
      <file line="95"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableMap.java"/>
      <file line="57"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedMapFauxverideShim.java"/>
      <codefragment><![CDATA[  public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(
      Function<? super T, ? extends K> keyFunction,
      Function<? super T, ? extends V> valueFunction,
      BinaryOperator<V> mergeFunction) {]]></codefragment>
   </duplication>
   <duplication lines="4" tokens="55">
      <file line="75"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedMap.java"/>
      <file line="93"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedMap.java"/>
      <codefragment><![CDATA[  public static <T, K, V> Collector<T, ?, ImmutableSortedMap<K, V>> toImmutableSortedMap(
      Comparator<? super K> comparator,
      Function<? super T, ? extends K> keyFunction,
      Function<? super T, ? extends V> valueFunction) {]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="55">
      <file line="1086"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Sets.java"/>
      <file line="1125"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Sets.java"/>
      <codefragment><![CDATA[  public static <E> SortedSet<E> filter(SortedSet<E> unfiltered, Predicate<? super E> predicate) {
    if (unfiltered instanceof FilteredSet) {
      // Support clear(), removeAll(), and retainAll() when filtering a filtered
      // collection.
      FilteredSet<E> filtered = (FilteredSet<E>) unfiltered;
      Predicate<E> combinedPredicate = Predicates.<E>and(filtered.predicate, predicate);
      return new FilteredSortedSet<E>((SortedSet<E>) filtered.unfiltered, combinedPredicate);]]></codefragment>
   </duplication>
   <duplication lines="4" tokens="55">
      <file line="56"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/AbstractByteHasher.java"/>
      <file line="75"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/AbstractHasher.java"/>
      <codefragment><![CDATA[      update(b.array(), b.arrayOffset() + b.position(), b.remaining());
      b.position(b.limit());
    } else {
      for (int remaining = b.remaining(); remaining > 0; remaining--) {]]></codefragment>
   </duplication>
   <duplication lines="9" tokens="55">
      <file line="270"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/LongMath.java"/>
      <file line="604"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/LongMath.java"/>
      <file line="718"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/LongMath.java"/>
      <codefragment><![CDATA[    if (-2 <= b && b <= 2) {
      switch ((int) b) {
        case 0:
          return (k == 0) ? 1 : 0;
        case 1:
          return 1;
        case (-1):
          return ((k & 1) == 0) ? 1 : -1;
        case 2:]]></codefragment>
   </duplication>
   <duplication lines="16" tokens="55">
      <file line="261"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Booleans.java"/>
      <file line="186"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Bytes.java"/>
      <file line="341"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Chars.java"/>
      <file line="330"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Doubles.java"/>
      <file line="325"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Floats.java"/>
      <file line="389"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Ints.java"/>
      <file line="485"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Longs.java"/>
      <file line="388"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Shorts.java"/>
      <codefragment><![CDATA[  public static boolean[] ensureCapacity(boolean[] array, int minLength, int padding) {
    checkArgument(minLength >= 0, "Invalid minLength: %s", minLength);
    checkArgument(padding >= 0, "Invalid padding: %s", padding);
    return (array.length < minLength) ? Arrays.copyOf(array, minLength + padding) : array;
  }

  /**
   * Returns a string containing the supplied {@code boolean} values separated by {@code separator}.
   * For example, {@code join("-", false, true, false)} returns the string {@code
   * "false-true-false"}.
   *
   * @param separator the text that should appear between consecutive values in the resulting string
   *     (but not at the start or end)
   * @param array an array of {@code boolean} values, possibly empty
   */
  public static String join(String separator, boolean... array) {]]></codefragment>
   </duplication>
   <duplication lines="17" tokens="54">
      <file line="1047"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1111"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1175"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1239"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <codefragment><![CDATA[      T obj, @Nullable String errorMessageTemplate, char p1, @Nullable Object p2) {
    if (obj == null) {
      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
    }
    return obj;
  }

  /**
   * Ensures that an object reference passed as a parameter to the calling method is not null.
   *
   * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
   *
   * @since 20.0 (varargs overload since 2.0)
   */
  @CanIgnoreReturnValue
  public static <T extends @NonNull Object> T checkNotNull(
      T obj, @Nullable String errorMessageTemplate, int p1, char p2) {]]></codefragment>
   </duplication>
   <duplication lines="17" tokens="54">
      <file line="1175"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1191"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1207"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1223"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1239"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <codefragment><![CDATA[      T obj, @Nullable String errorMessageTemplate, long p1, @Nullable Object p2) {
    if (obj == null) {
      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
    }
    return obj;
  }

  /**
   * Ensures that an object reference passed as a parameter to the calling method is not null.
   *
   * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
   *
   * @since 20.0 (varargs overload since 2.0)
   */
  @CanIgnoreReturnValue
  public static <T extends @NonNull Object> T checkNotNull(
      T obj, @Nullable String errorMessageTemplate, @Nullable Object p1, char p2) {]]></codefragment>
   </duplication>
   <duplication lines="16" tokens="54">
      <file line="985"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/CacheBuilder.java"/>
      <file line="284"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMaker.java"/>
      <codefragment><![CDATA[  }

  /**
   * Returns a string representation for this CacheBuilder instance. The exact form of the returned
   * string is not specified.
   */
  @Override
  public String toString() {
    MoreObjects.ToStringHelper s = MoreObjects.toStringHelper(this);
    if (initialCapacity != UNSET_INT) {
      s.add("initialCapacity", initialCapacity);
    }
    if (concurrencyLevel != UNSET_INT) {
      s.add("concurrencyLevel", concurrencyLevel);
    }
    if (maximumSize != UNSET_INT) {]]></codefragment>
   </duplication>
   <duplication lines="10" tokens="54">
      <file line="4241"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2439"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[  @Override
  public boolean remove(@Nullable Object key, @Nullable Object value) {
    if (key == null || value == null) {
      return false;
    }
    int hash = hash(key);
    return segmentFor(hash).remove(key, hash, value);
  }

  @Override]]></codefragment>
   </duplication>
   <duplication lines="18" tokens="54">
      <file line="282"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/AbstractBiMap.java"/>
      <file line="2066"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Sets.java"/>
      <codefragment><![CDATA[      return Maps.valueIterator(entrySet().iterator());
    }

    @Override
    public Object[] toArray() {
      return standardToArray();
    }

    @Override
    public <T> T[] toArray(T[] array) {
      return standardToArray(array);
    }

    @Override
    public String toString() {
      return standardToString();
    }
  }]]></codefragment>
   </duplication>
   <duplication lines="9" tokens="54">
      <file line="1373"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/AbstractMapBasedMultimap.java"/>
      <file line="245"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/FilteredEntryMultimap.java"/>
      <codefragment><![CDATA[    class AsMapEntries extends Maps.EntrySet<K, Collection<V>> {
      @Override
      Map<K, Collection<V>> map() {
        return AsMap.this;
      }

      @Override
      public Iterator<Entry<K, Collection<V>>> iterator() {
        return new AsMapIterator();]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="54">
      <file line="79"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/AbstractSortedMultiset.java"/>
      <file line="91"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/AbstractSortedMultiset.java"/>
      <codefragment><![CDATA[    Iterator<Entry<E>> entryIterator = entryIterator();
    if (entryIterator.hasNext()) {
      Entry<E> result = entryIterator.next();
      result = Multisets.immutableEntry(result.getElement(), result.getCount());
      entryIterator.remove();
      return result;
    }
    return null;
  }

  @Override
  public Entry<E> pollLastEntry() {]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="54">
      <file line="171"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/AbstractTable.java"/>
      <file line="3506"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Maps.java"/>
      <codefragment><![CDATA[  }

  private transient @MonotonicNonNull Collection<V> values;

  @Override
  public Collection<V> values() {
    Collection<V> result = values;
    return (result == null) ? values = createValues() : result;
  }

  Collection<V> createValues() {
    return new Values();]]></codefragment>
   </duplication>
   <duplication lines="4" tokens="54">
      <file line="77"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CollectCollectors.java"/>
      <file line="93"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedMap.java"/>
      <codefragment><![CDATA[  static <T, K, V> Collector<T, ?, ImmutableSortedMap<K, V>> toImmutableSortedMap(
      Comparator<? super K> comparator,
      Function<? super T, ? extends K> keyFunction,
      Function<? super T, ? extends V> valueFunction) {]]></codefragment>
   </duplication>
   <duplication lines="15" tokens="54">
      <file line="493"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Collections2.java"/>
      <file line="604"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Collections2.java"/>
      <codefragment><![CDATA[      return new OrderedPermutationIterator<E>(inputList, comparator);
    }

    @Override
    public boolean contains(@Nullable Object obj) {
      if (obj instanceof List) {
        List<?> list = (List<?>) obj;
        return isPermutation(inputList, list);
      }
      return false;
    }

    @Override
    public String toString() {
      return "orderedPermutationCollection(" + inputList + ")";]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="54">
      <file line="545"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashMap.java"/>
      <file line="781"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashMap.java"/>
      <codefragment><![CDATA[      return ObjectArrays.copyAsObjectArray(keys, 0, size);
    }

    @Override
    public <T> T[] toArray(T[] a) {
      if (needsAllocArrays()) {
        if (a.length > 0) {
          a[0] = null;
        }
        return a;
      }
      return ObjectArrays.toArrayImpl(keys, 0, size, a);]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="54">
      <file line="86"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableMultiset.java"/>
      <file line="88"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedMultiset.java"/>
      <codefragment><![CDATA[        LinkedHashMultiset::create,
        (multiset, t) ->
            multiset.add(checkNotNull(elementFunction.apply(t)), countFunction.applyAsInt(t)),
        (multiset1, multiset2) -> {
          multiset1.addAll(multiset2);
          return multiset1;
        },
        (Multiset<E> multiset) -> copyFromEntries(multiset.entrySet()));]]></codefragment>
   </duplication>
   <duplication lines="10" tokens="54">
      <file line="367"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSet.java"/>
      <file line="51"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/IndexedImmutableSet.java"/>
      <codefragment><![CDATA[    int copyIntoArray(Object[] dst, int offset) {
      return asList().copyIntoArray(dst, offset);
    }

    @Override
    ImmutableList<E> createAsList() {
      return new ImmutableAsList<E>() {
        @Override
        public E get(int index) {
          return Indexed.this.get(index);]]></codefragment>
   </duplication>
   <duplication lines="16" tokens="54">
      <file line="537"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Lists.java"/>
      <file line="587"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Lists.java"/>
      <codefragment><![CDATA[    TransformingSequentialList(List<F> fromList, Function<? super F, ? extends T> function) {
      this.fromList = checkNotNull(fromList);
      this.function = checkNotNull(function);
    }

    /**
     * The default implementation inherited is based on iteration and removal of each element which
     * can be overkill. That's why we forward this call directly to the backing list.
     */
    @Override
    public void clear() {
      fromList.clear();
    }

    @Override
    public int size() {]]></codefragment>
   </duplication>
   <duplication lines="4" tokens="54">
      <file line="2166"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <file line="2179"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <codefragment><![CDATA[      FilteredMultimap<K, V> multimap, Predicate<? super Entry<K, V>> entryPredicate) {
    Predicate<Entry<K, V>> predicate =
        Predicates.<Entry<K, V>>and(multimap.entryPredicate(), entryPredicate);
    return new FilteredEntryMultimap<>(multimap.unfiltered(), predicate);]]></codefragment>
   </duplication>
   <duplication lines="5" tokens="54">
      <file line="655"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/StandardTable.java"/>
      <file line="691"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/StandardTable.java"/>
      <codefragment><![CDATA[      boolean changed = false;
      Iterator<Map<C, V>> iterator = backingMap.values().iterator();
      while (iterator.hasNext()) {
        Map<C, V> map = iterator.next();
        if (map.keySet().remove(obj)) {]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="54">
      <file line="674"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeMultiset.java"/>
      <file line="692"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/TreeMultiset.java"/>
      <codefragment><![CDATA[        left = initLeft.remove(comparator, e, count, result);

        if (result[0] > 0) {
          if (count >= result[0]) {
            this.distinctElements--;
            this.totalCount -= result[0];
          } else {
            this.totalCount -= count;
          }
        }
        return (result[0] == 0) ? this : rebalance();]]></codefragment>
   </duplication>
   <duplication lines="15" tokens="54">
      <file line="143"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/AbstractBaseGraph.java"/>
      <file line="231"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/AbstractNetwork.java"/>
      <codefragment><![CDATA[    return nodes().contains(nodeU) && successors(nodeU).contains(nodeV);
  }

  /**
   * Throws {@code IllegalArgumentException} if the ordering of {@code endpoints} is not compatible
   * with the directionality of this graph.
   */
  protected final void validateEndpoints(EndpointPair<?> endpoints) {
    checkNotNull(endpoints);
    checkArgument(isOrderingCompatible(endpoints), ENDPOINTS_MISMATCH);
  }

  protected final boolean isOrderingCompatible(EndpointPair<?> endpoints) {
    return endpoints.isOrdered() || !this.isDirected();
  }]]></codefragment>
   </duplication>
   <duplication lines="13" tokens="54">
      <file line="284"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Graphs.java"/>
      <file line="438"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Graphs.java"/>
      <codefragment><![CDATA[      return delegate().inDegree(node); // transpose
    }

    @Override
    public boolean hasEdgeConnecting(N nodeU, N nodeV) {
      return delegate().hasEdgeConnecting(nodeV, nodeU); // transpose
    }

    @Override
    public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {
      return delegate().hasEdgeConnecting(transpose(endpoints));
    }
  }]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="54">
      <file line="419"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/BigIntegerMath.java"/>
      <file line="649"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/IntMath.java"/>
      <codefragment><![CDATA[  public static BigInteger binomial(int n, int k) {
    checkNonNegative("n", n);
    checkNonNegative("k", k);
    checkArgument(k <= n, "k (%s) > n (%s)", k, n);
    if (k > (n >> 1)) {
      k = n - k;
    }
    if (k < LongMath.biggestBinomials.length && n <= LongMath.biggestBinomials[k]) {]]></codefragment>
   </duplication>
   <duplication lines="18" tokens="54">
      <file line="388"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Booleans.java"/>
      <file line="250"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Bytes.java"/>
      <file line="520"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Chars.java"/>
      <file line="525"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Doubles.java"/>
      <file line="517"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Floats.java"/>
      <file line="570"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Ints.java"/>
      <file line="667"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Longs.java"/>
      <file line="568"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Shorts.java"/>
      <codefragment><![CDATA[    BooleanArrayAsList(boolean[] array, int start, int end) {
      this.array = array;
      this.start = start;
      this.end = end;
    }

    @Override
    public int size() {
      return end - start;
    }

    @Override
    public boolean isEmpty() {
      return false;
    }

    @Override
    public Boolean get(int index) {]]></codefragment>
   </duplication>
   <duplication lines="9" tokens="53">
      <file line="1373"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/AbstractMapBasedMultimap.java"/>
      <file line="245"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/FilteredEntryMultimap.java"/>
      <file line="1841"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <codefragment><![CDATA[    class AsMapEntries extends Maps.EntrySet<K, Collection<V>> {
      @Override
      Map<K, Collection<V>> map() {
        return AsMap.this;
      }

      @Override
      public Iterator<Entry<K, Collection<V>>> iterator() {
        return new AsMapIterator();]]></codefragment>
   </duplication>
   <duplication lines="10" tokens="53">
      <file line="280"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableBiMap.java"/>
      <file line="378"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableMap.java"/>
      <codefragment><![CDATA[          if (valueComparator != null) {
            if (entriesUsed) {
              entries = Arrays.copyOf(entries, size);
            }
            Arrays.sort(
                entries,
                0,
                size,
                Ordering.from(valueComparator).onResultOf(Maps.<V>valueFunction()));
          }]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="53">
      <file line="168"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedMap.java"/>
      <file line="180"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedMap.java"/>
      <codefragment><![CDATA[    return ofEntries(entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3));
  }

  /**
   * Returns an immutable sorted map containing the given entries, sorted by the natural ordering of
   * their keys.
   *
   * @throws IllegalArgumentException if any two keys are equal according to their natural ordering
   */
  @SuppressWarnings("unchecked")
  public static <K extends Comparable<? super K>, V> ImmutableSortedMap<K, V> of(
      K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {]]></codefragment>
   </duplication>
   <duplication lines="14" tokens="53">
      <file line="399"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedMultiset.java"/>
      <file line="388"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedSet.java"/>
      <codefragment><![CDATA[  public static <E> Builder<E> orderedBy(Comparator<E> comparator) {
    return new Builder<E>(comparator);
  }

  /**
   * Returns a builder that creates immutable sorted multisets whose elements are ordered by the
   * reverse of their natural ordering.
   *
   * <p>Note: the type parameter {@code E} extends {@code Comparable<?>} rather than {@code
   * Comparable<? super E>} as a workaround for javac <a
   * href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354">bug 6468354</a>.
   */
  public static <E extends Comparable<?>> Builder<E> reverseOrder() {
    return new Builder<E>(Ordering.natural().reverse());]]></codefragment>
   </duplication>
   <duplication lines="5" tokens="53">
      <file line="857"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Iterables.java"/>
      <file line="896"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Iterables.java"/>
      <codefragment><![CDATA[      public Iterator<T> iterator() {
        if (iterable instanceof List) {
          final List<T> list = (List<T>) iterable;
          int toSkip = Math.min(list.size(), numberToSkip);
          return list.subList(toSkip, list.size()).iterator();]]></codefragment>
   </duplication>
   <duplication lines="6" tokens="53">
      <file line="1692"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1732"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1820"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1847"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[        int newCount = this.count - 1;
        AtomicReferenceArray<E> table = this.table;
        int index = hash & (table.length() - 1);
        E first = table.get(index);

        for (E e = first; e != null; e = e.getNext()) {]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="53">
      <file line="329"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Graphs.java"/>
      <file line="438"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/Graphs.java"/>
      <codefragment><![CDATA[      return delegate().inDegree(node); // transpose
    }

    @Override
    public boolean hasEdgeConnecting(N nodeU, N nodeV) {
      return delegate().hasEdgeConnecting(nodeV, nodeU); // transpose
    }

    @Override
    public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {
      return delegate().hasEdgeConnecting(transpose(endpoints));
    }]]></codefragment>
   </duplication>
   <duplication lines="37" tokens="53">
      <file line="178"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableDoubleArray.java"/>
      <file line="175"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableIntArray.java"/>
      <file line="177"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableLongArray.java"/>
      <codefragment><![CDATA[    return (array.length == 0) ? EMPTY : new ImmutableDoubleArray(array);
  }

  /**
   * Returns a new, empty builder for {@link ImmutableDoubleArray} instances, sized to hold up to
   * {@code initialCapacity} values without resizing. The returned builder is not thread-safe.
   *
   * <p><b>Performance note:</b> When feasible, {@code initialCapacity} should be the exact number
   * of values that will be added, if that knowledge is readily available. It is better to guess a
   * value slightly too high than slightly too low. If the value is not exact, the {@link
   * ImmutableDoubleArray} that is built will very likely occupy more memory than strictly
   * necessary; to trim memory usage, build using {@code builder.build().trimmed()}.
   */
  public static Builder builder(int initialCapacity) {
    checkArgument(initialCapacity >= 0, "Invalid initialCapacity: %s", initialCapacity);
    return new Builder(initialCapacity);
  }

  /**
   * Returns a new, empty builder for {@link ImmutableDoubleArray} instances, with a default initial
   * capacity. The returned builder is not thread-safe.
   *
   * <p><b>Performance note:</b> The {@link ImmutableDoubleArray} that is built will very likely
   * occupy more memory than necessary; to trim memory usage, build using {@code
   * builder.build().trimmed()}.
   */
  public static Builder builder() {
    return new Builder(10);
  }

  /**
   * A builder for {@link ImmutableDoubleArray} instances; obtained using {@link
   * ImmutableDoubleArray#builder}.
   */
  @CanIgnoreReturnValue
  public static final class Builder {
    private double[] array;]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="53">
      <file line="396"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/UnsignedBytes.java"/>
      <file line="417"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/UnsignedBytes.java"/>
      <codefragment><![CDATA[        for (; i < minLength; i++) {
          int result = UnsignedBytes.compare(left[i], right[i]);
          if (result != 0) {
            return result;
          }
        }
        return left.length - right.length;
      }

      @Override
      public String toString() {
        return "UnsignedBytes.lexicographicalComparator() (sun.misc.Unsafe version)";]]></codefragment>
   </duplication>
   <duplication lines="17" tokens="52">
      <file line="999"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1063"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1127"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1191"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <codefragment><![CDATA[      T obj, @Nullable String errorMessageTemplate, char p1, char p2) {
    if (obj == null) {
      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
    }
    return obj;
  }

  /**
   * Ensures that an object reference passed as a parameter to the calling method is not null.
   *
   * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
   *
   * @since 20.0 (varargs overload since 2.0)
   */
  @CanIgnoreReturnValue
  public static <T extends @NonNull Object> T checkNotNull(
      T obj, @Nullable String errorMessageTemplate, char p1, int p2) {]]></codefragment>
   </duplication>
   <duplication lines="17" tokens="52">
      <file line="999"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1015"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1031"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <codefragment><![CDATA[      T obj, @Nullable String errorMessageTemplate, char p1, char p2) {
    if (obj == null) {
      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
    }
    return obj;
  }

  /**
   * Ensures that an object reference passed as a parameter to the calling method is not null.
   *
   * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
   *
   * @since 20.0 (varargs overload since 2.0)
   */
  @CanIgnoreReturnValue
  public static <T extends @NonNull Object> T checkNotNull(
      T obj, @Nullable String errorMessageTemplate, char p1, int p2) {]]></codefragment>
   </duplication>
   <duplication lines="17" tokens="52">
      <file line="1015"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1079"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1143"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1207"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <codefragment><![CDATA[      T obj, @Nullable String errorMessageTemplate, char p1, int p2) {
    if (obj == null) {
      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
    }
    return obj;
  }

  /**
   * Ensures that an object reference passed as a parameter to the calling method is not null.
   *
   * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
   *
   * @since 20.0 (varargs overload since 2.0)
   */
  @CanIgnoreReturnValue
  public static <T extends @NonNull Object> T checkNotNull(
      T obj, @Nullable String errorMessageTemplate, char p1, long p2) {]]></codefragment>
   </duplication>
   <duplication lines="17" tokens="52">
      <file line="1031"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1095"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1159"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1223"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <codefragment><![CDATA[      T obj, @Nullable String errorMessageTemplate, char p1, long p2) {
    if (obj == null) {
      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
    }
    return obj;
  }

  /**
   * Ensures that an object reference passed as a parameter to the calling method is not null.
   *
   * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
   *
   * @since 20.0 (varargs overload since 2.0)
   */
  @CanIgnoreReturnValue
  public static <T extends @NonNull Object> T checkNotNull(
      T obj, @Nullable String errorMessageTemplate, char p1, @Nullable Object p2) {]]></codefragment>
   </duplication>
   <duplication lines="17" tokens="52">
      <file line="1047"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1063"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1079"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1095"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <codefragment><![CDATA[      T obj, @Nullable String errorMessageTemplate, char p1, @Nullable Object p2) {
    if (obj == null) {
      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
    }
    return obj;
  }

  /**
   * Ensures that an object reference passed as a parameter to the calling method is not null.
   *
   * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
   *
   * @since 20.0 (varargs overload since 2.0)
   */
  @CanIgnoreReturnValue
  public static <T extends @NonNull Object> T checkNotNull(
      T obj, @Nullable String errorMessageTemplate, int p1, char p2) {]]></codefragment>
   </duplication>
   <duplication lines="17" tokens="52">
      <file line="1111"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1127"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1143"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1159"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <codefragment><![CDATA[      T obj, @Nullable String errorMessageTemplate, int p1, @Nullable Object p2) {
    if (obj == null) {
      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
    }
    return obj;
  }

  /**
   * Ensures that an object reference passed as a parameter to the calling method is not null.
   *
   * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
   *
   * @since 20.0 (varargs overload since 2.0)
   */
  @CanIgnoreReturnValue
  public static <T extends @NonNull Object> T checkNotNull(
      T obj, @Nullable String errorMessageTemplate, long p1, char p2) {]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="52">
      <file line="1348"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <file line="1393"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Preconditions.java"/>
      <codefragment><![CDATA[  private static String badElementIndex(int index, int size, @Nullable String desc) {
    if (index < 0) {
      return lenientFormat("%s (%s) must not be negative", desc, index);
    } else if (size < 0) {
      throw new IllegalArgumentException("negative size: " + size);
    } else { // index >= size
      return lenientFormat("%s (%s) must be less than size (%s)", desc, index, size);]]></codefragment>
   </duplication>
   <duplication lines="9" tokens="52">
      <file line="345"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Predicates.java"/>
      <file line="387"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/base/Predicates.java"/>
      <codefragment><![CDATA[    private AndPredicate(List<? extends Predicate<? super T>> components) {
      this.components = components;
    }

    @Override
    public boolean apply(@Nullable T t) {
      // Avoid using the Iterator to avoid generating garbage (issue 820).
      for (int i = 0; i < components.size(); i++) {
        if (!components.get(i).apply(t)) {]]></codefragment>
   </duplication>
   <duplication lines="6" tokens="52">
      <file line="2094"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3313"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="3389"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[        int newCount = this.count - 1;
        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
        int index = hash & (table.length() - 1);
        ReferenceEntry<K, V> first = table.get(index);

        for (e = first; e != null; e = e.getNext()) {]]></codefragment>
   </duplication>
   <duplication lines="8" tokens="52">
      <file line="299"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/AbstractBiMap.java"/>
      <file line="4130"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Maps.java"/>
      <codefragment><![CDATA[  }

  private transient @MonotonicNonNull Set<Entry<K, V>> entrySet;

  @Override
  public Set<Entry<K, V>> entrySet() {
    Set<Entry<K, V>> result = entrySet;
    return (result == null) ? entrySet = new EntrySet() : result;]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="52">
      <file line="391"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashMap.java"/>
      <file line="368"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactHashSet.java"/>
      <codefragment><![CDATA[        if (last == UNSET) {
          // we need to update the root link from table[]
          table[tableIndex] = getNext(entries[next]);
        } else {
          // we need to update the link from the chain
          entries[last] = swapNext(entries[last], getNext(entries[next]));
        }

        moveLastEntry(next);
        size--;
        modCount++;
        return oldValue;]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="52">
      <file line="398"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableList.java"/>
      <file line="355"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSet.java"/>
      <file line="38"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/IndexedImmutableSet.java"/>
      <codefragment><![CDATA[  }

  @Override
  public void forEach(Consumer<? super E> consumer) {
    checkNotNull(consumer);
    int n = size();
    for (int i = 0; i < n; i++) {
      consumer.accept(get(i));
    }
  }

  @Override]]></codefragment>
   </duplication>
   <duplication lines="5" tokens="52">
      <file line="425"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableListMultimap.java"/>
      <file line="479"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSetMultimap.java"/>
      <codefragment><![CDATA[  private ImmutableListMultimap<V, K> invert() {
    Builder<V, K> builder = builder();
    for (Entry<K, V> entry : entries()) {
      builder.put(entry.getValue(), entry.getKey());
    }]]></codefragment>
   </duplication>
   <duplication lines="19" tokens="52">
      <file line="205"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedMultiset.java"/>
      <file line="206"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedSet.java"/>
      <codefragment><![CDATA[  public static <E> ImmutableSortedMultiset<E> copyOf(Iterable<? extends E> elements) {
    // Hack around E not being a subtype of Comparable.
    // Unsafe, see ImmutableSortedMultisetFauxverideShim.
    @SuppressWarnings("unchecked")
    Ordering<E> naturalOrder = (Ordering<E>) Ordering.<Comparable>natural();
    return copyOf(naturalOrder, elements);
  }

  /**
   * Returns an immutable sorted multiset containing the given elements sorted by their natural
   * ordering.
   *
   * <p>This method is not type-safe, as it may be called on elements that are not mutually
   * comparable.
   *
   * @throws ClassCastException if the elements are not mutually comparable
   * @throws NullPointerException if any of {@code elements} is null
   */
  public static <E> ImmutableSortedMultiset<E> copyOf(Iterator<? extends E> elements) {]]></codefragment>
   </duplication>
   <duplication lines="19" tokens="52">
      <file line="205"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedMultiset.java"/>
      <file line="223"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedMultiset.java"/>
      <codefragment><![CDATA[  public static <E> ImmutableSortedMultiset<E> copyOf(Iterable<? extends E> elements) {
    // Hack around E not being a subtype of Comparable.
    // Unsafe, see ImmutableSortedMultisetFauxverideShim.
    @SuppressWarnings("unchecked")
    Ordering<E> naturalOrder = (Ordering<E>) Ordering.<Comparable>natural();
    return copyOf(naturalOrder, elements);
  }

  /**
   * Returns an immutable sorted multiset containing the given elements sorted by their natural
   * ordering.
   *
   * <p>This method is not type-safe, as it may be called on elements that are not mutually
   * comparable.
   *
   * @throws ClassCastException if the elements are not mutually comparable
   * @throws NullPointerException if any of {@code elements} is null
   */
  public static <E> ImmutableSortedMultiset<E> copyOf(Iterator<? extends E> elements) {]]></codefragment>
   </duplication>
   <duplication lines="15" tokens="52">
      <file line="223"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedMultiset.java"/>
      <file line="257"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedSet.java"/>
      <codefragment><![CDATA[  public static <E> ImmutableSortedMultiset<E> copyOf(Iterator<? extends E> elements) {
    // Hack around E not being a subtype of Comparable.
    // Unsafe, see ImmutableSortedMultisetFauxverideShim.
    @SuppressWarnings("unchecked")
    Ordering<E> naturalOrder = (Ordering<E>) Ordering.<Comparable>natural();
    return copyOf(naturalOrder, elements);
  }

  /**
   * Returns an immutable sorted multiset containing the given elements sorted by the given {@code
   * Comparator}.
   *
   * @throws NullPointerException if {@code comparator} or any of {@code elements} is null
   */
  public static <E> ImmutableSortedMultiset<E> copyOf(]]></codefragment>
   </duplication>
   <duplication lines="33" tokens="52">
      <file line="206"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedSet.java"/>
      <file line="238"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedSet.java"/>
      <file line="257"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSortedSet.java"/>
      <codefragment><![CDATA[  public static <E> ImmutableSortedSet<E> copyOf(Iterable<? extends E> elements) {
    // Hack around E not being a subtype of Comparable.
    // Unsafe, see ImmutableSortedSetFauxverideShim.
    @SuppressWarnings("unchecked")
    Ordering<E> naturalOrder = (Ordering<E>) Ordering.<Comparable>natural();
    return copyOf(naturalOrder, elements);
  }

  /**
   * Returns an immutable sorted set containing the given elements sorted by their natural ordering.
   * When multiple elements are equivalent according to {@code compareTo()}, only the first one
   * specified is included. To create a copy of a {@code SortedSet} that preserves the comparator,
   * call {@link #copyOfSorted} instead. This method iterates over {@code elements} at most once.
   *
   * <p>Note that if {@code s} is a {@code Set<String>}, then {@code ImmutableSortedSet.copyOf(s)}
   * returns an {@code ImmutableSortedSet<String>} containing each of the strings in {@code s},
   * while {@code ImmutableSortedSet.of(s)} returns an {@code ImmutableSortedSet<Set<String>>}
   * containing one element (the given set itself).
   *
   * <p><b>Note:</b> Despite what the method name suggests, if {@code elements} is an {@code
   * ImmutableSortedSet}, it may be returned instead of a copy.
   *
   * <p>This method is not type-safe, as it may be called on elements that are not mutually
   * comparable.
   *
   * <p>This method is safe to use even when {@code elements} is a synchronized or concurrent
   * collection that is currently being modified by another thread.
   *
   * @throws ClassCastException if the elements are not mutually comparable
   * @throws NullPointerException if any of {@code elements} is null
   * @since 7.0 (source-compatible since 2.0)
   */
  public static <E> ImmutableSortedSet<E> copyOf(Collection<? extends E> elements) {]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="52">
      <file line="509"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Iterables.java"/>
      <file line="535"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Iterables.java"/>
      <codefragment><![CDATA[  public static <T> Iterable<List<T>> partition(final Iterable<T> iterable, final int size) {
    checkNotNull(iterable);
    checkArgument(size > 0);
    return new FluentIterable<List<T>>() {
      @Override
      public Iterator<List<T>> iterator() {
        return Iterators.partition(iterable.iterator(), size);]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="52">
      <file line="688"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Iterators.java"/>
      <file line="732"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Iterators.java"/>
      <codefragment><![CDATA[  public static <T> T find(Iterator<T> iterator, Predicate<? super T> predicate) {
    checkNotNull(iterator);
    checkNotNull(predicate);
    while (iterator.hasNext()) {
      T t = iterator.next();
      if (predicate.apply(t)) {
        return t;]]></codefragment>
   </duplication>
   <duplication lines="16" tokens="52">
      <file line="2686"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="2720"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[      return new KeyIterator();
    }

    @Override
    public int size() {
      return MapMakerInternalMap.this.size();
    }

    @Override
    public boolean isEmpty() {
      return MapMakerInternalMap.this.isEmpty();
    }

    @Override
    public boolean contains(Object o) {
      return MapMakerInternalMap.this.containsKey(o);]]></codefragment>
   </duplication>
   <duplication lines="3" tokens="52">
      <file line="2667"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Maps.java"/>
      <file line="2689"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Maps.java"/>
      <codefragment><![CDATA[      FilteredEntrySortedMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {
    Predicate<Entry<K, V>> predicate = Predicates.<Entry<K, V>>and(map.predicate, entryPredicate);
    return new FilteredEntrySortedMap<>(map.sortedMap(), predicate);]]></codefragment>
   </duplication>
   <duplication lines="3" tokens="52">
      <file line="171"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/StandardTable.java"/>
      <file line="457"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/StandardTable.java"/>
      <codefragment><![CDATA[    Iterator<Entry<R, Map<C, V>>> iterator = backingMap.entrySet().iterator();
    while (iterator.hasNext()) {
      Entry<R, Map<C, V>> entry = iterator.next();]]></codefragment>
   </duplication>
   <duplication lines="31" tokens="52">
      <file line="410"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Streams.java"/>
      <file line="489"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Streams.java"/>
      <file line="568"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Streams.java"/>
      <codefragment><![CDATA[      Splitr createSplit(Spliterator<T> from, long i) {
        return new Splitr(from, i);
      }
    }
    return StreamSupport.stream(new Splitr(fromSpliterator, 0), isParallel).onClose(stream::close);
  }

  /**
   * Returns a stream consisting of the results of applying the given function to the elements of
   * {@code stream} and their indexes in the stream. For example,
   *
   * <pre>{@code
   * mapWithIndex(
   *     IntStream.of(0, 1, 2),
   *     (i, index) -> i + ":" + index)
   * }</pre>
   *
   * <p>...would return {@code Stream.of("0:0", "1:1", "2:2")}.
   *
   * <p>The resulting stream is <a
   * href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>
   * if and only if {@code stream} was efficiently splittable and its underlying spliterator
   * reported {@link Spliterator#SUBSIZED}. This is generally the case if the underlying stream
   * comes from a data structure supporting efficient indexed random access, typically an array or
   * list.
   *
   * <p>The order of the resulting stream is defined if and only if the order of the original stream
   * was defined.
   */
  @Beta
  public static <R> Stream<R> mapWithIndex(IntStream stream, IntFunctionWithIndex<R> function) {]]></codefragment>
   </duplication>
   <duplication lines="20" tokens="52">
      <file line="1480"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Synchronized.java"/>
      <file line="1893"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Synchronized.java"/>
      <codefragment><![CDATA[        return delegate().lower(e);
      }
    }

    @Override
    public E pollFirst() {
      synchronized (mutex) {
        return delegate().pollFirst();
      }
    }

    @Override
    public E pollLast() {
      synchronized (mutex) {
        return delegate().pollLast();
      }
    }

    @Override
    public NavigableSet<E> subSet(]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="52">
      <file line="529"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/Hashing.java"/>
      <file line="553"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/Hashing.java"/>
      <codefragment><![CDATA[    byte[] resultBytes = new byte[bits / 8];
    for (HashCode hashCode : hashCodes) {
      byte[] nextBytes = hashCode.asBytes();
      checkArgument(
          nextBytes.length == resultBytes.length, "All hashcodes must have the same bit length.");
      for (int i = 0; i < nextBytes.length; i++) {
        resultBytes[i] = (byte) (resultBytes[i] * 37 ^ nextBytes[i]);]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="51">
      <file line="2060"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="2722"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[    V get(Object key, int hash) {
      try {
        if (count != 0) { // read-volatile
          long now = map.ticker.read();
          ReferenceEntry<K, V> e = getLiveEntry(key, hash, now);
          if (e == null) {
            return null;]]></codefragment>
   </duplication>
   <duplication lines="16" tokens="51">
      <file line="4517"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="4617"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <codefragment><![CDATA[      map.clear();
    }

    // super.toArray() may misbehave if size() is inaccurate, at least on old versions of Android.
    // https://code.google.com/p/android/issues/detail?id=36519 / http://r.android.com/47508

    @Override
    public Object[] toArray() {
      return toArrayList(this).toArray();
    }

    @Override
    public <E> E[] toArray(E[] a) {
      return toArrayList(this).toArray(a);
    }
  }]]></codefragment>
   </duplication>
   <duplication lines="6" tokens="51">
      <file line="301"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/AbstractBiMap.java"/>
      <file line="3488"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Maps.java"/>
      <codefragment><![CDATA[  private transient @MonotonicNonNull Set<Entry<K, V>> entrySet;

  @Override
  public Set<Entry<K, V>> entrySet() {
    Set<Entry<K, V>> result = entrySet;
    return (result == null) ? entrySet = new EntrySet() : result;]]></codefragment>
   </duplication>
   <duplication lines="9" tokens="51">
      <file line="60"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/AbstractSortedSetMultimap.java"/>
      <file line="439"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <codefragment><![CDATA[      return Collections.unmodifiableSortedSet((SortedSet<E>) collection);
    }
  }

  @Override
  Collection<V> wrapCollection(K key, Collection<V> collection) {
    if (collection instanceof NavigableSet) {
      return new WrappedNavigableSet(key, (NavigableSet<V>) collection, null);
    } else {]]></codefragment>
   </duplication>
   <duplication lines="13" tokens="51">
      <file line="220"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactLinkedHashMap.java"/>
      <file line="242"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactLinkedHashMap.java"/>
      <codefragment><![CDATA[    class KeySetImpl extends KeySetView {
      @Override
      public Object[] toArray() {
        return ObjectArrays.toArrayImpl(this);
      }

      @Override
      public <T> T[] toArray(T[] a) {
        return ObjectArrays.toArrayImpl(this, a);
      }

      @Override
      public Spliterator<K> spliterator() {]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="51">
      <file line="358"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableListMultimap.java"/>
      <file line="407"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSetMultimap.java"/>
      <codefragment><![CDATA[  public static <K, V> ImmutableListMultimap<K, V> copyOf(
      Iterable<? extends Entry<? extends K, ? extends V>> entries) {
    return new Builder<K, V>().putAll(entries).build();
  }

  /** Creates an ImmutableListMultimap from an asMap.entrySet. */
  static <K, V> ImmutableListMultimap<K, V> fromMapEntries(]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="51">
      <file line="624"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MinMaxPriorityQueue.java"/>
      <file line="659"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MinMaxPriorityQueue.java"/>
      <codefragment><![CDATA[      E parentElement = elementData(parentIndex);
      if (parentIndex != 0) {
        // This is a guard for the case of the childless uncle.
        // Since the end of the array is actually the middle of the heap,
        // a smaller childless uncle can become a child of x when we
        // bubble up alternate levels, violating the invariant.
        int grandparentIndex = getParentIndex(parentIndex);
        int uncleIndex = getRightChildIndex(grandparentIndex);
        if (uncleIndex != parentIndex && getLeftChildIndex(uncleIndex) >= size) {
          E uncleElement = elementData(uncleIndex);
          if (ordering.compare(uncleElement, parentElement) < 0) {]]></codefragment>
   </duplication>
   <duplication lines="11" tokens="51">
      <file line="28"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/NullsFirstOrdering.java"/>
      <file line="28"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/NullsLastOrdering.java"/>
      <codefragment><![CDATA[  NullsFirstOrdering(Ordering<? super T> ordering) {
    this.ordering = ordering;
  }

  @Override
  public int compare(@Nullable T left, @Nullable T right) {
    if (left == right) {
      return 0;
    }
    if (left == null) {
      return RIGHT_IS_GREATER;]]></codefragment>
   </duplication>
   <duplication lines="13" tokens="51">
      <file line="87"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/ForwardingGraph.java"/>
      <file line="150"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/ForwardingNetwork.java"/>
      <codefragment><![CDATA[    return delegate().outDegree(node);
  }

  @Override
  public boolean hasEdgeConnecting(N nodeU, N nodeV) {
    return delegate().hasEdgeConnecting(nodeU, nodeV);
  }

  @Override
  public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {
    return delegate().hasEdgeConnecting(endpoints);
  }
}]]></codefragment>
   </duplication>
   <duplication lines="5" tokens="51">
      <file line="130"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/HashCode.java"/>
      <file line="187"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/hash/HashCode.java"/>
      <codefragment><![CDATA[    }

    @Override
    public byte[] asBytes() {
      return new byte[] {(byte) hash, (byte) (hash >> 8), (byte) (hash >> 16), (byte) (hash >> 24)};]]></codefragment>
   </duplication>
   <duplication lines="7" tokens="51">
      <file line="419"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/BigIntegerMath.java"/>
      <file line="649"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/IntMath.java"/>
      <file line="808"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/math/LongMath.java"/>
      <codefragment><![CDATA[  public static BigInteger binomial(int n, int k) {
    checkNonNegative("n", n);
    checkNonNegative("k", k);
    checkArgument(k <= n, "k (%s) > n (%s)", k, n);
    if (k > (n >> 1)) {
      k = n - k;
    }]]></codefragment>
   </duplication>
   <duplication lines="22" tokens="51">
      <file line="283"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Booleans.java"/>
      <file line="355"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Doubles.java"/>
      <file line="350"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Floats.java"/>
      <file line="410"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Ints.java"/>
      <file line="506"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Longs.java"/>
      <file line="410"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/Shorts.java"/>
      <file line="150"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/SignedBytes.java"/>
      <codefragment><![CDATA[    StringBuilder builder = new StringBuilder(array.length * 7);
    builder.append(array[0]);
    for (int i = 1; i < array.length; i++) {
      builder.append(separator).append(array[i]);
    }
    return builder.toString();
  }

  /**
   * Returns a comparator that compares two {@code boolean} arrays <a
   * href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographically</a>. That is, it
   * compares, using {@link #compare(boolean, boolean)}), the first pair of values that follow any
   * common prefix, or when one array is a prefix of the other, treats the shorter array as the
   * lesser. For example, {@code [] < [false] < [false, true] < [true]}.
   *
   * <p>The returned comparator is inconsistent with {@link Object#equals(Object)} (since arrays
   * support only identity equality), but it is consistent with {@link Arrays#equals(boolean[],
   * boolean[])}.
   *
   * @since 2.0
   */
  public static Comparator<boolean[]> lexicographicalComparator() {]]></codefragment>
   </duplication>
   <duplication lines="22" tokens="51">
      <file line="249"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/UnsignedBytes.java"/>
      <file line="173"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/UnsignedInts.java"/>
      <file line="138"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/UnsignedLongs.java"/>
      <codefragment><![CDATA[    builder.append(toInt(array[0]));
    for (int i = 1; i < array.length; i++) {
      builder.append(separator).append(toString(array[i]));
    }
    return builder.toString();
  }

  /**
   * Returns a comparator that compares two {@code byte} arrays <a
   * href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographically</a>. That is, it
   * compares, using {@link #compare(byte, byte)}), the first pair of values that follow any common
   * prefix, or when one array is a prefix of the other, treats the shorter array as the lesser. For
   * example, {@code [] < [0x01] < [0x01, 0x7F] < [0x01, 0x80] < [0x02]}. Values are treated as
   * unsigned.
   *
   * <p>The returned comparator is inconsistent with {@link Object#equals(Object)} (since arrays
   * support only identity equality), but it is consistent with {@link
   * java.util.Arrays#equals(byte[], byte[])}.
   *
   * @since 2.0
   */
  public static Comparator<byte[]> lexicographicalComparator() {]]></codefragment>
   </duplication>
   <duplication lines="13" tokens="50">
      <file line="355"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/CacheBuilder.java"/>
      <file line="143"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMaker.java"/>
      <codefragment><![CDATA[  public CacheBuilder<K, V> initialCapacity(int initialCapacity) {
    checkState(
        this.initialCapacity == UNSET_INT,
        "initial capacity was already set to %s",
        this.initialCapacity);
    checkArgument(initialCapacity >= 0);
    this.initialCapacity = initialCapacity;
    return this;
  }

  int getInitialCapacity() {
    return (initialCapacity == UNSET_INT) ? DEFAULT_INITIAL_CAPACITY : initialCapacity;
  }]]></codefragment>
   </duplication>
   <duplication lines="13" tokens="50">
      <file line="400"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/CacheBuilder.java"/>
      <file line="177"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMaker.java"/>
      <codefragment><![CDATA[  public CacheBuilder<K, V> concurrencyLevel(int concurrencyLevel) {
    checkState(
        this.concurrencyLevel == UNSET_INT,
        "concurrency level was already set to %s",
        this.concurrencyLevel);
    checkArgument(concurrencyLevel > 0);
    this.concurrencyLevel = concurrencyLevel;
    return this;
  }

  int getConcurrencyLevel() {
    return (concurrencyLevel == UNSET_INT) ? DEFAULT_CONCURRENCY_LEVEL : concurrencyLevel;
  }]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="50">
      <file line="2885"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/cache/LocalCache.java"/>
      <file line="1570"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[            for (ReferenceEntry<K, V> e = next; e != null; e = e.getNext()) {
              int newIndex = e.getHash() & newMask;
              if (newIndex != tailIndex) {
                // The index changed. We'll need to copy the previous entry.
                tailIndex = newIndex;
                tail = e;
              }
            }
            newTable.set(tailIndex, tail);

            // Clone nodes leading up to the tail.
            for (ReferenceEntry<K, V> e = head; e != tail; e = e.getNext()) {]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="50">
      <file line="221"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactLinkedHashMap.java"/>
      <file line="243"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactLinkedHashMap.java"/>
      <file line="218"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/CompactLinkedHashSet.java"/>
      <codefragment><![CDATA[      @Override
      public Object[] toArray() {
        return ObjectArrays.toArrayImpl(this);
      }

      @Override
      public <T> T[] toArray(T[] a) {
        return ObjectArrays.toArrayImpl(this, a);
      }

      @Override
      public Spliterator<K> spliterator() {]]></codefragment>
   </duplication>
   <duplication lines="22" tokens="50">
      <file line="158"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ConcurrentHashMultiset.java"/>
      <file line="562"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ConcurrentHashMultiset.java"/>
      <codefragment><![CDATA[  }

  /*
   * Note: the superclass toArray() methods assume that size() gives a correct
   * answer, which ours does not.
   */

  @Override
  public Object[] toArray() {
    return snapshot().toArray();
  }

  @Override
  public <T> T[] toArray(T[] array) {
    return snapshot().toArray(array);
  }

  /*
   * We'd love to use 'new ArrayList(this)' or 'list.addAll(this)', but
   * either of these would recurse back to us again!
   */
  private List<E> snapshot() {]]></codefragment>
   </duplication>
   <duplication lines="6" tokens="50">
      <file line="73"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/FilteredMultimapValues.java"/>
      <file line="82"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/FilteredMultimapValues.java"/>
      <codefragment><![CDATA[  public boolean removeAll(Collection<?> c) {
    return Iterables.removeIf(
        multimap.unfiltered().entries(),
        // explicit <Entry<K, V>> is required to build with JDK6
        Predicates.<Entry<K, V>>and(
            multimap.entryPredicate(), Maps.<V>valuePredicateOnEntries(Predicates.in(c))));]]></codefragment>
   </duplication>
   <duplication lines="10" tokens="50">
      <file line="173"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableListMultimap.java"/>
      <file line="195"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/ImmutableSetMultimap.java"/>
      <codefragment><![CDATA[    ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();
    builder.put(k1, v1);
    builder.put(k2, v2);
    builder.put(k3, v3);
    builder.put(k4, v4);
    return builder.build();
  }

  /** Returns an immutable multimap containing the given entries, in order. */
  public static <K, V> ImmutableListMultimap<K, V> of(]]></codefragment>
   </duplication>
   <duplication lines="6" tokens="50">
      <file line="1483"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1603"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1650"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1821"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1884"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <file line="1913"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/MapMakerInternalMap.java"/>
      <codefragment><![CDATA[        AtomicReferenceArray<E> table = this.table;
        int index = hash & (table.length() - 1);
        E first = table.get(index);

        // Look for an existing entry.
        for (E e = first; e != null; e = e.getNext()) {]]></codefragment>
   </duplication>
   <duplication lines="5" tokens="50">
      <file line="261"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <file line="445"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/collect/Multimaps.java"/>
      <codefragment><![CDATA[      } else if (collection instanceof NavigableSet) {
        return new WrappedNavigableSet(key, (NavigableSet<V>) collection, null);
      } else if (collection instanceof SortedSet) {
        return new WrappedSortedSet(key, (SortedSet<V>) collection, null);
      } else if (collection instanceof Set) {]]></codefragment>
   </duplication>
   <duplication lines="12" tokens="50">
      <file line="150"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/ForwardingNetwork.java"/>
      <file line="90"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/graph/ForwardingValueGraph.java"/>
      <codefragment><![CDATA[    return delegate().edgeConnectingOrNull(endpoints);
  }

  @Override
  public boolean hasEdgeConnecting(N nodeU, N nodeV) {
    return delegate().hasEdgeConnecting(nodeU, nodeV);
  }

  @Override
  public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {
    return delegate().hasEdgeConnecting(endpoints);
  }]]></codefragment>
   </duplication>
   <duplication lines="23" tokens="50">
      <file line="353"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableDoubleArray.java"/>
      <file line="350"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableIntArray.java"/>
      <file line="352"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableLongArray.java"/>
      <codefragment><![CDATA[  private ImmutableDoubleArray(double[] array, int start, int end) {
    this.array = array;
    this.start = start;
    this.end = end;
  }

  /** Returns the number of values in this array. */
  public int length() {
    return end - start;
  }

  /** Returns {@code true} if there are no values in this array ({@link #length} is zero). */
  public boolean isEmpty() {
    return end == start;
  }

  /**
   * Returns the {@code double} value present at the given index.
   *
   * @throws IndexOutOfBoundsException if {@code index} is negative, or greater than or equal to
   *     {@link #length}
   */
  public double get(int index) {]]></codefragment>
   </duplication>
   <duplication lines="15" tokens="50">
      <file line="615"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableDoubleArray.java"/>
      <file line="605"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableIntArray.java"/>
      <file line="607"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/primitives/ImmutableLongArray.java"/>
      <codefragment><![CDATA[    return isPartialView() ? new ImmutableDoubleArray(toArray()) : this;
  }

  private boolean isPartialView() {
    return start > 0 || end < array.length;
  }

  Object writeReplace() {
    return trimmed();
  }

  Object readResolve() {
    return isEmpty() ? EMPTY : this;
  }
}]]></codefragment>
   </duplication>
   <duplication lines="20" tokens="50">
      <file line="99"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/Uninterruptibles.java"/>
      <file line="140"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/Uninterruptibles.java"/>
      <codefragment><![CDATA[          return latch.await(remainingNanos, NANOSECONDS);
        } catch (InterruptedException e) {
          interrupted = true;
          remainingNanos = end - System.nanoTime();
        }
      }
    } finally {
      if (interrupted) {
        Thread.currentThread().interrupt();
      }
    }
  }

  /**
   * Invokes {@code condition.}{@link Condition#await(long, TimeUnit) await(timeout, unit)}
   * uninterruptibly.
   *
   * @since 28.0
   */
  @GwtIncompatible // concurrency]]></codefragment>
   </duplication>
   <duplication lines="16" tokens="50">
      <file line="140"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/Uninterruptibles.java"/>
      <file line="307"
            path="/home/raffaele/Scrivania/guava-28.0/com/google/common/util/concurrent/Uninterruptibles.java"/>
      <codefragment><![CDATA[          return condition.await(remainingNanos, NANOSECONDS);
        } catch (InterruptedException e) {
          interrupted = true;
          remainingNanos = end - System.nanoTime();
        }
      }
    } finally {
      if (interrupted) {
        Thread.currentThread().interrupt();
      }
    }
  }

  /** Invokes {@code toJoin.}{@link Thread#join() join()} uninterruptibly. */
  @GwtIncompatible // concurrency
  public static void joinUninterruptibly(Thread toJoin) {]]></codefragment>
   </duplication>
</pmd-cpd>